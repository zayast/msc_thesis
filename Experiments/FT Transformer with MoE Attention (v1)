{"cells":[{"cell_type":"code","execution_count":24,"metadata":{"executionInfo":{"elapsed":31,"status":"ok","timestamp":1760889073387,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"QYO-HYkgZ4T3"},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import pandas as pd\n","import numpy as np\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import accuracy_score\n","from torch.utils.data import DataLoader, TensorDataset\n","from torch.optim import Adam\n","from sklearn.model_selection import train_test_split\n","import matplotlib.pyplot as plt"]},{"cell_type":"code","execution_count":25,"metadata":{"id":"VdpcwaM9z4TN","executionInfo":{"status":"ok","timestamp":1760889073399,"user_tz":-480,"elapsed":4,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"outputs":[],"source":["from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay\n","from sklearn.metrics import precision_score, recall_score, f1_score, classification_report\n","from sklearn.metrics import roc_auc_score, precision_recall_curve, f1_score"]},{"cell_type":"code","execution_count":26,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2579,"status":"ok","timestamp":1760889077010,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"7lEomYw8aQbh","outputId":"b11c173a-e0df-4d64-ca27-c1c6f6ae9074"},"outputs":[{"output_type":"stream","name":"stdout","text":["Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"markdown","metadata":{"id":"5Q9MHkvXys9q"},"source":["=====================Data prepration============================="]},{"cell_type":"code","execution_count":27,"metadata":{"executionInfo":{"elapsed":2,"status":"ok","timestamp":1760889077015,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"JEb6Fm_HcbCy"},"outputs":[],"source":["# -----------------\n","# Helper: stratified sampling\n","# -----------------\n","def stratified_sample(df, target_col, frac=None, n=None, random_state=42):\n","    \"\"\"Return stratified sample keeping target ratio\"\"\"\n","    if frac is not None:\n","        df_sampled = df.groupby(target_col, group_keys=False)\\\n","                       .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n","    elif n is not None:\n","        class_counts = df[target_col].value_counts()\n","        total = class_counts.sum()\n","        df_sampled = []\n","        for c, count in class_counts.items():\n","            take = int(n * (count / total))\n","            df_sampled.append(df[df[target_col] == c].sample(n=take, random_state=random_state))\n","        df_sampled = pd.concat(df_sampled)\n","    else:\n","        df_sampled = df\n","    return df_sampled.sample(frac=1.0, random_state=random_state).reset_index(drop=True)"]},{"cell_type":"code","source":["dataset = \"B\"\n","\n","if dataset == \"A\":\n","  dataset_name = \"/content/drive/MyDrive/wustl_iiot_2021.csv\"\n","  target = 'Target'\n","  drop_cols = [\"StartTime\", \"LastTime\", \"Traffic\", \"SrcAddr\", \"DstAddr\"]\n","  frac=0.1\n","elif dataset == \"B\":\n","  dataset_name = \"/content/drive/MyDrive/creditcard.csv\"\n","  target = 'Class'\n","  drop_cols = [\"Time\"]\n","  frac=0.5"],"metadata":{"id":"zNLyODO3h4nL","executionInfo":{"status":"ok","timestamp":1760889083270,"user_tz":-480,"elapsed":3,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":28,"outputs":[]},{"cell_type":"code","execution_count":29,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6663,"status":"ok","timestamp":1760889093748,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"tqQUooD0aAPH","outputId":"5ff84525-dfd7-43b3-bff3-5f5618dfcc00"},"outputs":[{"output_type":"stream","name":"stdout","text":["Original dataset shape: (284807, 30), anomaly ratio=0.1727%\n","Sampled dataset shape: (142404, 30), anomaly ratio=0.1727%\n"]},{"output_type":"stream","name":"stderr","text":["/tmp/ipython-input-2184620091.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n","  .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n"]},{"output_type":"stream","name":"stdout","text":["Train shape: (75948, 30), anomaly ratio=0.1725%\n","Valid shape: (37975, 30), anomaly ratio=0.1738%\n","Test shape:  (28481, 30),  anomaly ratio=0.1720%\n","['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']\n","Categorical columns: []\n","Numerical columns: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']\n","[]\n","[]\n"]}],"source":["df = pd.read_csv(dataset_name)\n","\n","df = df.drop(columns=[c for c in drop_cols if c in df.columns])\n","\n","print(f\"Original dataset shape: {df.shape}, anomaly ratio={df[target].mean():.4%}\")\n","\n","# Stratified sampling\n","df_sampled = stratified_sample(df, target, frac=frac, random_state=0)\n","print(f\"Sampled dataset shape: {df_sampled.shape}, anomaly ratio={df_sampled[target].mean():.4%}\")\n","\n","df_sampled = df_sampled.reset_index(drop=True)\n","\n","features = df_sampled.columns\n","\n","train_df, test_df = train_test_split(\n","    df_sampled, test_size=0.2, stratify=df_sampled[target], random_state=0\n",")\n","\n","train_df, valid_df = train_test_split(\n","    train_df, test_size= 0.2 / 0.6, stratify=train_df[target], random_state=0\n",")\n","\n","print(f\"Train shape: {train_df.shape}, anomaly ratio={train_df[target].mean():.4%}\")\n","print(f\"Valid shape: {valid_df.shape}, anomaly ratio={valid_df[target].mean():.4%}\")\n","print(f\"Test shape:  {test_df.shape},  anomaly ratio={test_df[target].mean():.4%}\")\n","\n","# Add the \"Set\" column\n","train_df[\"Set\"] = \"train\"\n","valid_df[\"Set\"] = \"valid\"\n","test_df[\"Set\"] = \"test\"\n","\n","# Combine them back together\n","train = pd.concat([train_df, valid_df, test_df]).reset_index(drop=True)\n","\n","train_indices = train[train.Set == \"train\"].index\n","valid_indices = train[train.Set == \"valid\"].index\n","test_indices = train[train.Set == \"test\"].index\n","\n","\n","categorical_columns = []\n","numerical_columns = []\n","categorical_dims = {}\n","\n","nunique = train.nunique()\n","types = train.dtypes\n","\n","for col in train.columns:\n","    if col == target or col == 'Set':\n","        continue\n","    if types[col] == 'object':\n","        l_enc = LabelEncoder()\n","        train[col] = train[col].fillna(\"VV_likely\")\n","        train[col] = l_enc.fit_transform(train[col].values)\n","        categorical_columns.append(col)\n","        categorical_dims[col] = len(l_enc.classes_)\n","    else:\n","        train.fillna(train.loc[train_indices, col].mean(), inplace=True)\n","        numerical_columns.append(col)\n","\n","unused_feat = [\"Set\"]\n","\n","features = [col for col in df_sampled.columns if col not in unused_feat + [target]]\n","\n","print(features)\n","print(\"Categorical columns:\", categorical_columns)\n","print(\"Numerical columns:\", numerical_columns)\n","\n","cat_idxs = [i for i, f in enumerate(features) if f in categorical_columns]\n","\n","print(cat_idxs)\n","cat_dims = [categorical_dims[f] for i, f in enumerate(features) if f in categorical_columns]\n","print(cat_dims)"]},{"cell_type":"code","execution_count":30,"metadata":{"executionInfo":{"elapsed":6,"status":"ok","timestamp":1760889096616,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"c-yxDUQHxt6F"},"outputs":[],"source":["target_enc = LabelEncoder()\n","train[target] = target_enc.fit_transform(train[target].values)"]},{"cell_type":"code","execution_count":31,"metadata":{"executionInfo":{"elapsed":3,"status":"ok","timestamp":1760889098246,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"oXFTqW5IblTA"},"outputs":[],"source":["X_train = train[features].values[train_indices]\n","y_train = train[target].values[train_indices]\n","\n","X_valid = train[features].values[valid_indices]\n","y_valid = train[target].values[valid_indices]\n","\n","X_test = train[features].values[test_indices]\n","y_test = train[target].values[test_indices]"]},{"cell_type":"code","source":["X_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"lrzMwFTWTTB8","executionInfo":{"status":"ok","timestamp":1760889100112,"user_tz":-480,"elapsed":5,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"e1fc40de-ebd1-4173-f471-5236be93ccd1"},"execution_count":32,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([[-1.19197911e+00,  3.65650122e-01, -8.51445584e-01,\n","        -5.55876464e-02,  6.60455094e-01, -8.97987761e-01,\n","         9.17589518e-01, -1.09320231e+00, -3.04718385e-03,\n","        -3.14985028e-01,  1.37842811e+00,  5.80745705e-01,\n","         4.10150716e-02, -7.67188541e-01,  1.12237566e-01,\n","         2.29330820e-01,  2.57217208e-01,  1.05117226e+00,\n","         7.67926875e-02, -6.39738004e-01,  9.28457312e-01,\n","         1.00805213e+00,  5.59219071e-01, -4.87668841e-02,\n","        -1.88406839e-01, -1.33895716e-01,  3.85090717e-01,\n","         1.49271649e-01,  9.90000000e+01],\n","       [-1.10183428e+00,  1.42811407e+00,  1.75677727e+00,\n","         4.57016384e+00, -7.85317014e-01,  1.74108541e+00,\n","         4.60257243e-01,  4.84929055e-01, -7.22077270e-01,\n","         6.13497785e-01, -4.18485976e-01, -3.65065122e+00,\n","         1.53242701e+00,  1.78262993e+00,  7.01455562e-01,\n","         5.11940272e-01,  8.11029639e-01,  1.08387676e+00,\n","         7.74394808e-01,  1.48712822e-01,  1.01479933e-01,\n","         3.42363325e-01, -1.18869258e-01,  6.43704638e-01,\n","         1.74076932e-01,  4.92296165e-01, -9.15912795e-02,\n","        -2.42055297e-02,  2.26440000e+02]])"]},"metadata":{},"execution_count":32}]},{"cell_type":"code","source":["y_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6ZaXye2RTUKI","executionInfo":{"status":"ok","timestamp":1760889102591,"user_tz":-480,"elapsed":15,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"c77b1ebd-1af1-49d4-ec3d-396b71d4eb3d"},"execution_count":33,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([0, 0])"]},"metadata":{},"execution_count":33}]},{"cell_type":"code","execution_count":34,"metadata":{"executionInfo":{"elapsed":25,"status":"ok","timestamp":1760889104676,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"XEizQZmXgxQm"},"outputs":[],"source":["# Split the data into categorical and continuous parts\n","X_train_categ = torch.tensor(X_train[:, cat_idxs], dtype=torch.long)\n","X_train_cont = torch.tensor(np.delete(X_train, cat_idxs, axis=1), dtype=torch.float32)\n","y_train_tensor = torch.tensor(y_train, dtype=torch.long)\n","\n","X_valid_categ = torch.tensor(X_valid[:, cat_idxs], dtype=torch.long)\n","X_valid_cont = torch.tensor(np.delete(X_valid, cat_idxs, axis=1), dtype=torch.float32)\n","y_valid_tensor = torch.tensor(y_valid, dtype=torch.long)\n","\n","X_test_categ = torch.tensor(X_test[:, cat_idxs], dtype=torch.long)\n","X_test_cont = torch.tensor(np.delete(X_test, cat_idxs, axis=1), dtype=torch.float32)\n","y_test_tensor = torch.tensor(y_test, dtype=torch.long)\n","\n","# Create DataLoaders\n","train_dataset = TensorDataset(X_train_categ, X_train_cont, y_train_tensor)\n","train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n","\n","valid_dataset = TensorDataset(X_valid_categ, X_valid_cont, y_valid_tensor)\n","valid_loader = DataLoader(valid_dataset, batch_size=32, shuffle=False)\n","\n","test_dataset = TensorDataset(X_test_categ, X_test_cont, y_test_tensor)\n","test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)"]},{"cell_type":"markdown","metadata":{"id":"6t0AMSr8y2Pe"},"source":["======================================================================"]},{"cell_type":"markdown","metadata":{"id":"Lbv9mESCyQNX"},"source":["==================================Model================================"]},{"cell_type":"code","execution_count":35,"metadata":{"executionInfo":{"elapsed":3,"status":"ok","timestamp":1760889106012,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"t9qv3vmlzpQx"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","\n","from einops import rearrange"]},{"cell_type":"code","execution_count":69,"metadata":{"executionInfo":{"elapsed":31,"status":"ok","timestamp":1760891703643,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"5UmJ2xwyy-AA"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","from einops import rearrange, repeat\n","\n","# ---------- Helper: GEGLU Feedforward ----------\n","\n","class GEGLU(nn.Module):\n","    def forward(self, x):\n","        x, gates = x.chunk(2, dim=-1)\n","        return x * F.gelu(gates)\n","\n","def FeedForward(dim, mult=4, dropout=0.):\n","    return nn.Sequential(\n","        nn.LayerNorm(dim),\n","        nn.Linear(dim, dim * mult * 2),\n","        GEGLU(),\n","        nn.Dropout(dropout),\n","        nn.Linear(dim * mult, dim)\n","    )\n","\n","# ---------- SwitchHead (Mixture-of-Experts) Attention ----------\n","\n","class SwitchHeadAttention(nn.Module):\n","    def __init__(self, dim, num_experts=4, heads=8, dim_head=64, top_k=2, dropout=0.1):\n","        super().__init__()\n","        self.num_experts = num_experts\n","        self.heads = heads\n","        self.dim_head = dim_head\n","        self.scale = dim_head ** -0.5\n","        self.top_k = top_k\n","\n","        inner_dim = heads * dim_head\n","        self.norm = nn.LayerNorm(dim)\n","\n","        # Expert-specific linear layers\n","        self.qkv = nn.ModuleList([\n","            nn.Linear(dim, inner_dim * 3, bias=False) for _ in range(num_experts)\n","        ])\n","        self.outs = nn.ModuleList([\n","            nn.Linear(inner_dim, dim, bias=False) for _ in range(num_experts)\n","        ])\n","\n","        # Router network (assigns tokens to experts)\n","        self.router = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.Linear(dim, num_experts)\n","        )\n","\n","        self.dropout = nn.Dropout(dropout)\n","\n","    def forward(self, x):\n","        b, n, _ = x.shape\n","        x_norm = self.norm(x)\n","\n","        # Compute routing probabilities\n","        routing_logits = self.router(x_norm)                      # [b, n, num_experts]\n","        routing_probs = F.softmax(routing_logits, dim=-1)\n","\n","        # Top-k experts per token\n","        topk_vals, topk_idx = torch.topk(routing_probs, self.top_k, dim=-1)\n","        topk_vals = topk_vals / (topk_vals.sum(dim=-1, keepdim=True) + 1e-8)\n","\n","        expert_outputs = torch.zeros_like(x)\n","        all_attn_weights = []\n","\n","        for e_idx in range(self.num_experts):\n","            mask = (topk_idx == e_idx).any(dim=-1)\n","            if not mask.any():\n","                continue\n","\n","            qkv = self.qkv[e_idx](x_norm)\n","            q, k, v = qkv.chunk(3, dim=-1)\n","            q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h=self.heads), (q, k, v))\n","            q = q * self.scale\n","\n","            sim = einsum('b h i d, b h j d -> b h i j', q, k)\n","            attn = sim.softmax(dim=-1)\n","            attn = self.dropout(attn)\n","\n","            out = einsum('b h i j, b h j d -> b h i d', attn, v)\n","            out = rearrange(out, 'b h n d -> b n (h d)')\n","            out = self.outs[e_idx](out)\n","            all_attn_weights.append(attn)\n","\n","            expert_outputs += out * routing_probs[..., e_idx].unsqueeze(-1)\n","\n","        # Average attention maps across experts\n","        final_attn = torch.stack(all_attn_weights).mean(0) if all_attn_weights else None\n","\n","        # Load balancing loss (to avoid expert collapse)\n","        expert_usage = routing_probs.mean(dim=(0, 1))  # average over batch and tokens\n","        balance_loss = (expert_usage * torch.log(expert_usage * self.num_experts + 1e-9)).sum()\n","\n","        return expert_outputs, final_attn, routing_probs, balance_loss\n","\n","\n","# ---------- Transformer Layer (with SwitchHead Attention) ----------\n","\n","class Transformer(nn.Module):\n","    def __init__(self, dim, depth, heads, dim_head, attn_dropout, ff_dropout,\n","                 num_experts=4, top_k=2):\n","        super().__init__()\n","        self.layers = nn.ModuleList([])\n","        for _ in range(depth):\n","            self.layers.append(nn.ModuleList([\n","                SwitchHeadAttention(\n","                    dim, num_experts=num_experts, heads=heads,\n","                    dim_head=dim_head, top_k=top_k, dropout=attn_dropout\n","                ),\n","                FeedForward(dim, dropout=ff_dropout),\n","            ]))\n","\n","    def forward(self, x, return_attn=False):\n","        all_attn = []\n","        all_routing = []\n","        balance_losses = []\n","\n","        for attn, ff in self.layers:\n","            attn_out, attn_map, routing_probs, balance_loss = attn(x)\n","            x = x + attn_out\n","            x = x + ff(x)\n","\n","            balance_losses.append(balance_loss)\n","            if return_attn:\n","                all_attn.append(attn_map)\n","                all_routing.append(routing_probs)\n","\n","        total_balance_loss = torch.stack(balance_losses).mean()\n","\n","        if return_attn:\n","            return x, torch.stack(all_attn), torch.stack(all_routing), total_balance_loss\n","        return x, total_balance_loss\n","\n","\n","# ---------- Numerical Embedder ----------\n","\n","class NumericalEmbedder(nn.Module):\n","    def __init__(self, dim, num_numerical_types):\n","        super().__init__()\n","        self.weights = nn.Parameter(torch.randn(num_numerical_types, dim))\n","        self.biases = nn.Parameter(torch.randn(num_numerical_types, dim))\n","\n","    def forward(self, x):\n","        x = rearrange(x, 'b n -> b n 1')\n","        return x * self.weights + self.biases\n","\n","\n","# ---------- Full FTTransformer + SwitchHead ----------\n","\n","class FTTransformerSwitchHead(nn.Module):\n","    def __init__(self, *, categories, num_continuous, dim, depth, heads,\n","                 dim_head=16, dim_out=1, num_special_tokens=2,\n","                 attn_dropout=0., ff_dropout=0.,\n","                 num_experts=4, top_k=2):\n","        super().__init__()\n","        assert all(map(lambda n: n > 0, categories)), \"category sizes must be > 0\"\n","        assert len(categories) + num_continuous > 0, \"input shape cannot be null\"\n","\n","        self.num_categories = len(categories)\n","        self.num_unique_categories = sum(categories)\n","        self.num_special_tokens = num_special_tokens\n","        total_tokens = self.num_unique_categories + num_special_tokens\n","\n","        # categorical embeddings\n","        if self.num_unique_categories > 0:\n","            categories_offset = F.pad(torch.tensor(list(categories)), (1, 0), value=num_special_tokens)\n","            categories_offset = categories_offset.cumsum(dim=-1)[:-1]\n","            self.register_buffer('categories_offset', categories_offset)\n","            self.categorical_embeds = nn.Embedding(total_tokens, dim)\n","\n","        # continuous features\n","        self.num_continuous = num_continuous\n","        if num_continuous > 0:\n","            self.numerical_embedder = NumericalEmbedder(dim, num_continuous)\n","\n","        # cls token\n","        self.cls_token = nn.Parameter(torch.randn(1, 1, dim))\n","\n","        # transformer backbone\n","        self.transformer = Transformer(\n","            dim=dim, depth=depth, heads=heads, dim_head=dim_head,\n","            attn_dropout=attn_dropout, ff_dropout=ff_dropout,\n","            num_experts=num_experts, top_k=top_k\n","        )\n","\n","        # output projection\n","        self.to_logits = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.ReLU(),\n","            nn.Linear(dim, dim_out)\n","        )\n","\n","    def forward(self, x_categ, x_numer, return_attn=False):\n","        xs = []\n","        if self.num_unique_categories > 0:\n","            x_categ = x_categ + self.categories_offset\n","            xs.append(self.categorical_embeds(x_categ))\n","        if self.num_continuous > 0:\n","            xs.append(self.numerical_embedder(x_numer))\n","\n","        x = torch.cat(xs, dim=1)\n","        b = x.shape[0]\n","        cls_token = repeat(self.cls_token, '1 1 d -> b 1 d', b=b)\n","        x = torch.cat((cls_token, x), dim=1)\n","\n","        if return_attn:\n","            x, attns, routing, balance_loss = self.transformer(x, return_attn=True)\n","        else:\n","            x, balance_loss = self.transformer(x)\n","\n","        x_cls = x[:, 0]\n","        logits = self.to_logits(x_cls)\n","\n","        if not return_attn:\n","            return logits, balance_loss\n","        return logits, attns, routing, balance_loss"]},{"cell_type":"markdown","metadata":{"id":"GQbua9hnyb3t"},"source":["======================================================================="]},{"cell_type":"code","source":["device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")"],"metadata":{"id":"xw2OxaMb9nHI","executionInfo":{"status":"ok","timestamp":1760891435828,"user_tz":-480,"elapsed":4,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":65,"outputs":[]},{"cell_type":"code","execution_count":70,"metadata":{"executionInfo":{"elapsed":35,"status":"ok","timestamp":1760891718548,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"GP2nhw8Hx73H"},"outputs":[],"source":["model = FTTransformerSwitchHead(\n","    categories=cat_dims,\n","    num_continuous=len(features) - len(cat_dims), # number of continuous values\n","    dim=128,\n","    depth=4,\n","    heads=8,\n","    num_experts=4,\n","    top_k=2,\n","    dim_out=1\n",").to(device)"]},{"cell_type":"code","source":["from sklearn.utils.class_weight import compute_class_weight\n","from sklearn.metrics import precision_recall_curve, average_precision_score"],"metadata":{"id":"EloRm9Y5u9n0","executionInfo":{"status":"ok","timestamp":1760891720903,"user_tz":-480,"elapsed":1,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":71,"outputs":[]},{"cell_type":"code","source":["def get_best_threshold(y_true, y_probs, metric=\"f1\"):\n","    precision, recall, thresholds = precision_recall_curve(y_true, y_probs)\n","\n","    # Compute F1 for each threshold\n","    f1_scores = 2 * precision * recall / (precision + recall + 1e-8)\n","    auc_pr = average_precision_score(y_true, y_probs)\n","\n","    if metric == \"f1\":\n","        best_idx = np.argmax(f1_scores)\n","        best_score = f1_scores[best_idx]\n","    elif metric == \"precision\":\n","        best_idx = np.argmax(precision)\n","        best_score = precision[best_idx]\n","    elif metric == \"recall\":\n","        best_idx = np.argmax(recall)\n","        best_score = recall[best_idx]\n","    else:\n","        raise ValueError(\"metric must be one of: 'f1', 'precision', or 'recall'\")\n","\n","    best_threshold = thresholds[best_idx] if best_idx < len(thresholds) else 0.5\n","\n","    metrics = {\n","        \"best_metric\": metric,\n","        \"best_score\": best_score,\n","        \"best_threshold\": best_threshold,\n","        \"auc_pr\": auc_pr,\n","        \"precision_curve\": precision,\n","        \"recall_curve\": recall,\n","        \"f1_curve\": f1_scores,\n","        \"thresholds\": thresholds\n","    }\n","\n","    return best_threshold, metrics"],"metadata":{"id":"rakESQqwu-mZ","executionInfo":{"status":"ok","timestamp":1760891722366,"user_tz":-480,"elapsed":3,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":72,"outputs":[]},{"cell_type":"code","execution_count":73,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OquETEtzzZ-V","executionInfo":{"status":"ok","timestamp":1760892897689,"user_tz":-480,"elapsed":1039214,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"9fe25271-2c26-45d7-96ec-206dd9bd0a91"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","===== Epoch 1/10 =====\n","Train BCE: 0.4916 | BalanceReg: 0.26207 | Val Loss: 0.5223 | Val Acc: 0.9992 | Val AUC-PR: 0.6000 | Best F1: 0.7458 | Thresh: 0.9101\n","‚úÖ New best model saved (F1=0.7458)\n","\n","===== Epoch 2/10 =====\n","Train BCE: 0.3406 | BalanceReg: 0.19956 | Val Loss: 0.4261 | Val Acc: 0.9989 | Val AUC-PR: 0.6141 | Best F1: 0.6772 | Thresh: 0.8771\n","\n","===== Epoch 3/10 =====\n","Train BCE: 0.2902 | BalanceReg: 0.11198 | Val Loss: 0.5936 | Val Acc: 0.9992 | Val AUC-PR: 0.5738 | Best F1: 0.7333 | Thresh: 0.9963\n","\n","===== Epoch 4/10 =====\n","Train BCE: 0.3506 | BalanceReg: 0.15154 | Val Loss: 0.3115 | Val Acc: 0.9991 | Val AUC-PR: 0.5890 | Best F1: 0.7097 | Thresh: 0.9976\n","\n","===== Epoch 5/10 =====\n","Train BCE: 0.2862 | BalanceReg: 0.15715 | Val Loss: 0.4079 | Val Acc: 0.9991 | Val AUC-PR: 0.5504 | Best F1: 0.7273 | Thresh: 0.9709\n","\n","===== Epoch 6/10 =====\n","Train BCE: 0.3097 | BalanceReg: 0.19318 | Val Loss: 0.2937 | Val Acc: 0.9990 | Val AUC-PR: 0.6060 | Best F1: 0.7176 | Thresh: 0.9713\n","\n","===== Epoch 7/10 =====\n","Train BCE: 0.2681 | BalanceReg: 0.19566 | Val Loss: 0.2906 | Val Acc: 0.9990 | Val AUC-PR: 0.5644 | Best F1: 0.6935 | Thresh: 0.9596\n","\n","===== Epoch 8/10 =====\n","Train BCE: 0.3009 | BalanceReg: 0.21400 | Val Loss: 0.3275 | Val Acc: 0.9989 | Val AUC-PR: 0.4390 | Best F1: 0.6769 | Thresh: 0.9501\n","\n","===== Epoch 9/10 =====\n","Train BCE: 0.3623 | BalanceReg: 0.23467 | Val Loss: 0.4194 | Val Acc: 0.9990 | Val AUC-PR: 0.5244 | Best F1: 0.6935 | Thresh: 0.9905\n","\n","===== Epoch 10/10 =====\n","Train BCE: 0.3217 | BalanceReg: 0.29460 | Val Loss: 0.4816 | Val Acc: 0.9992 | Val AUC-PR: 0.5589 | Best F1: 0.7377 | Thresh: 0.9975\n","\n","Training completed. Best F1 = 0.745762706934789\n"]}],"source":["# === Optimizer and Class Weights ===\n","optimizer = Adam(model.parameters(), lr=1e-3)\n","\n","classes = np.unique(y_train)\n","class_weights = compute_class_weight(class_weight='balanced', classes=classes, y=y_train)\n","class_weights = torch.tensor(class_weights, dtype=torch.float).to(device)\n","\n","criterion = nn.BCEWithLogitsLoss(pos_weight=class_weights[1])\n","\n","# === Training Configuration ===\n","num_epochs = 10\n","lambda_balance = 0.01   # scaling for balance regularization\n","best_threshold = 0.5\n","best_f1 = 0.0\n","\n","for epoch in range(num_epochs):\n","    print(f\"\\n===== Epoch {epoch+1}/{num_epochs} =====\")\n","    model.train()\n","    train_loss = 0.0\n","    balance_reg_loss = 0.0\n","\n","    # ---------- TRAIN LOOP ----------\n","    for x_categ, x_cont, y in train_loader:\n","        x_categ, x_cont, y = x_categ.to(device), x_cont.to(device), y.to(device).float().unsqueeze(1)\n","\n","        optimizer.zero_grad()\n","\n","        # Model forward (returns logits + balance_loss)\n","        logits, balance_loss = model(x_categ, x_cont)\n","\n","        # Combine BCE and balance regularization\n","        bce_loss = criterion(logits, y)\n","        loss = bce_loss + lambda_balance * balance_loss\n","\n","        loss.backward()\n","        optimizer.step()\n","\n","        train_loss += bce_loss.item()\n","        balance_reg_loss += balance_loss.item()\n","\n","    avg_train_loss = train_loss / len(train_loader)\n","    avg_balance_loss = balance_reg_loss / len(train_loader)\n","\n","    # ---------- VALIDATION ----------\n","    model.eval()\n","    val_loss = 0.0\n","    all_val_probs, all_val_labels = [], []\n","\n","    with torch.no_grad():\n","        for x_categ, x_cont, y in valid_loader:\n","            x_categ, x_cont, y = x_categ.to(device), x_cont.to(device), y.to(device).float().unsqueeze(1)\n","\n","            logits, balance_loss = model(x_categ, x_cont)\n","            bce_loss = criterion(logits, y)\n","            val_loss += bce_loss.item()\n","\n","            probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","            all_val_probs.extend(probs)\n","            all_val_labels.extend(y.cpu().numpy().astype(int).squeeze(1).tolist())\n","\n","    avg_val_loss = val_loss / len(valid_loader)\n","\n","    # ---------- Dynamic Threshold Optimization ----------\n","    best_threshold, metrics = get_best_threshold(all_val_labels, all_val_probs, metric=\"f1\")\n","    preds_bin = (np.array(all_val_probs) >= best_threshold).astype(int)\n","    val_acc = accuracy_score(all_val_labels, preds_bin)\n","\n","    # ---------- Logging ----------\n","    print(f\"Train BCE: {avg_train_loss:.4f} | BalanceReg: {avg_balance_loss:.5f} | \"\n","          f\"Val Loss: {avg_val_loss:.4f} | Val Acc: {val_acc:.4f} | \"\n","          f\"Val AUC-PR: {metrics['auc_pr']:.4f} | \"\n","          f\"Best F1: {metrics['best_score']:.4f} | Thresh: {best_threshold:.4f}\")\n","\n","    # Save best model\n","    if metrics[\"best_score\"] > best_f1:\n","        best_f1 = metrics[\"best_score\"]\n","        torch.save(model.state_dict(), \"best_switchhead_ftt.pt\")\n","        print(f\"‚úÖ New best model saved (F1={best_f1:.4f})\")\n","\n","print(\"\\nTraining completed. Best F1 =\", best_f1)"]},{"cell_type":"code","execution_count":75,"metadata":{"id":"0_u9H5FB55j0","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1760893226476,"user_tz":-480,"elapsed":11750,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"4991eee9-abd4-4765-a335-ceb58ed90fc6"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","üîç Final Test Metrics:\n","Accuracy: 0.9993\n","F1 Score:  0.8000\n","AUC-PR:    0.6162\n","Best Threshold (from val): 0.9975\n"]}],"source":["# 5Ô∏è‚É£ Final test evaluation\n","model.eval()\n","all_test_probs = []\n","all_test_preds = []\n","\n","with torch.no_grad():\n","    for x_categ, x_cont, _ in test_loader:\n","        x_categ, x_cont = x_categ.to(device), x_cont.to(device)\n","\n","        # The model returns (logits, balance_loss)\n","        logits, _ = model(x_categ, x_cont)\n","\n","        # Convert logits ‚Üí probabilities\n","        probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","        all_test_probs.extend(probs)\n","\n","        # Apply optimal threshold found during validation\n","        preds_bin = (probs >= best_threshold).astype(int)\n","        all_test_preds.extend(preds_bin)\n","\n","# Convert to NumPy arrays\n","y_pred = np.array(all_test_preds)\n","y_prob = np.array(all_test_probs)\n","\n","# Optional: compute test metrics\n","test_acc = accuracy_score(y_test, y_pred)\n","test_f1 = f1_score(y_test, y_pred)\n","test_aucpr = average_precision_score(y_test, y_prob)\n","\n","print(f\"\\nüîç Final Test Metrics:\")\n","print(f\"Accuracy: {test_acc:.4f}\")\n","print(f\"F1 Score:  {test_f1:.4f}\")\n","print(f\"AUC-PR:    {test_aucpr:.4f}\")\n","print(f\"Best Threshold (from val): {best_threshold:.4f}\")"]},{"cell_type":"code","execution_count":76,"metadata":{"id":"zGZ9KqXK0AiS","colab":{"base_uri":"https://localhost:8080/","height":472},"executionInfo":{"status":"ok","timestamp":1760893231571,"user_tz":-480,"elapsed":5,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"4f7356cb-5be3-4fda-db2a-9fd25011cff5"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 2 Axes>"],"image/png":"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zrb69evrtddeU+vWrT0aHAAAnmTxIoEpxU4YwsLCLviApry8PIWGhnokKAAAPI0hCXOKPSTx8ssv6/HHH9emTZucbZs2bdKwYcP0yiuveDQ4AAA8pWDSo5mtONavX6+77rpLoaGhstlsWrp0qcv+vn37Flq22bFjR5c+J06cUJ8+fRQQEKCgoCANGDBAGRkZLn22bt2q1q1by9fXV2FhYZo8eXKhWD788EM1aNBAvr6+aty4sT777LPi3YyKWGGoVKmSS2aVmZmpyMhIlSt3/vBz586pXLly6t+/v7p3717sIAAAuNpkZmaqadOm6t+/v3r06HHBPh07dtTcuXOdn+12u8v+Pn366MiRI0pMTFRubq769eunRx55RAsXLpQkORwOdejQQdHR0ZozZ462bdum/v37KygoSI888ogkaePGjerVq5cmTZqkrl27auHCherevbu2bNmiRo0aFfl+ipQwTJs2rcgnBACgLLrcQxKdOnVSp06d/raP3W5XSEjIBfft3LlTK1eu1A8//KCWLVtKkl577TV17txZr7zyikJDQ7VgwQLl5OTo3XfflY+Pj2688UYlJydrypQpzoRh+vTp6tixo0aOHClJmjhxohITEzVz5kzNmTOnyPdTpIQhNja2yCcEAKAsKouPhl67dq2qV6+uSpUq6R//+IdeeOEFValSRZKUlJSkoKAgZ7IgSdHR0fLy8tJ3332ne+65R0lJSWrTpo18fHycfWJiYvR///d/OnnypCpVqqSkpCTFxcW5XDcmJqbQEIk7l/zgJknKyspSTk6OS1tAQICZUwIAUKY5HA6Xz3a7vdBQQlF07NhRPXr0UO3atbVv3z4988wz6tSpk5KSkuTt7a3U1FRVr17d5Zhy5cqpcuXKSk1NlSSlpqaqdu3aLn2Cg4Od+ypVqqTU1FRn25/7FJyjqIqdMGRmZmr06NFavHixjh8/Xmh/Xl5ecU8JAECJ89TrrcPCwlzax40bp/j4+GKfr2fPns4/N27cWE2aNFHdunW1du1a3XHHHZccZ0kp9iqJUaNGac2aNZo9e7bsdrvefvttjR8/XqGhoXrvvfdKIkYAAEyz2cxvknTo0CGlp6c7tzFjxngkvjp16qhq1arau3evJCkkJERHjx516XPu3DmdOHHCOe8hJCREaWlpLn0KPrvrc7G5ExdT7IRh2bJlmjVrlu69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\n"},"metadata":{}}],"source":["# Confusion Matrix\n","cm = confusion_matrix(y_test, y_pred)\n","disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n","disp.plot(cmap=plt.cm.Blues)\n","plt.title(\"Confusion Matrix\")\n","plt.show()"]},{"cell_type":"code","source":["# Accuracy, Precision, Recall, F1-Score\n","accuracy = accuracy_score(y_test, y_pred)\n","precision = precision_score(y_test, y_pred)\n","recall = recall_score(y_test, y_pred)\n","f1 = f1_score(y_test, y_pred)\n","auc = roc_auc_score(y_test, y_pred)\n","\n","\n","# Print individual scores\n","print(f\"Accuracy: {accuracy:.4f}\")\n","print(f\"Precision: {precision:.4f}\")\n","print(f\"Recall: {recall:.4f}\")\n","print(f\"F1-Score: {f1:.4f}\")\n","print(f\"ROC-AUC: {auc:.4f}\")\n","\n","# Classification report for a detailed overview\n","print(classification_report(y_test, y_pred))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"VhO2p17A9x-K","executionInfo":{"status":"ok","timestamp":1760893235879,"user_tz":-480,"elapsed":30,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"2880a87f-a61b-43b0-a2f5-3552e3278ed5"},"execution_count":77,"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 0.9993\n","Precision: 0.8261\n","Recall: 0.7755\n","F1-Score: 0.8000\n","ROC-AUC: 0.8876\n","              precision    recall  f1-score   support\n","\n","           0       1.00      1.00      1.00     28432\n","           1       0.83      0.78      0.80        49\n","\n","    accuracy                           1.00     28481\n","   macro avg       0.91      0.89      0.90     28481\n","weighted avg       1.00      1.00      1.00     28481\n","\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"iogJ7zeoAorG"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"gpuType":"A100","authorship_tag":"ABX9TyObnnV39AJTLIafpa1Mg2Mx"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"},"accelerator":"GPU"},"nbformat":4,"nbformat_minor":0}