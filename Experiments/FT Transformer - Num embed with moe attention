{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"executionInfo":{"elapsed":8634,"status":"ok","timestamp":1760957119751,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"QYO-HYkgZ4T3"},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import pandas as pd\n","import numpy as np\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import accuracy_score\n","from torch.utils.data import DataLoader, TensorDataset\n","from torch.optim import Adam\n","from sklearn.model_selection import train_test_split\n","import matplotlib.pyplot as plt"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"VdpcwaM9z4TN","executionInfo":{"status":"ok","timestamp":1760957119763,"user_tz":-480,"elapsed":5,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"outputs":[],"source":["from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay\n","from sklearn.metrics import precision_score, recall_score, f1_score, classification_report\n","from sklearn.metrics import roc_auc_score, precision_recall_curve, f1_score"]},{"cell_type":"code","execution_count":3,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":19310,"status":"ok","timestamp":1760957141827,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"7lEomYw8aQbh","outputId":"6e414075-5bce-4195-b45c-486fd606ed15"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"markdown","metadata":{"id":"5Q9MHkvXys9q"},"source":["=====================Data prepration============================="]},{"cell_type":"code","execution_count":4,"metadata":{"executionInfo":{"elapsed":4,"status":"ok","timestamp":1760957143076,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"JEb6Fm_HcbCy"},"outputs":[],"source":["# -----------------\n","# Helper: stratified sampling\n","# -----------------\n","def stratified_sample(df, target_col, frac=None, n=None, random_state=42):\n","    \"\"\"Return stratified sample keeping target ratio\"\"\"\n","    if frac is not None:\n","        df_sampled = df.groupby(target_col, group_keys=False)\\\n","                       .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n","    elif n is not None:\n","        class_counts = df[target_col].value_counts()\n","        total = class_counts.sum()\n","        df_sampled = []\n","        for c, count in class_counts.items():\n","            take = int(n * (count / total))\n","            df_sampled.append(df[df[target_col] == c].sample(n=take, random_state=random_state))\n","        df_sampled = pd.concat(df_sampled)\n","    else:\n","        df_sampled = df\n","    return df_sampled.sample(frac=1.0, random_state=random_state).reset_index(drop=True)"]},{"cell_type":"code","source":["dataset = \"B\"\n","\n","if dataset == \"A\":\n","  dataset_name = \"/content/drive/MyDrive/wustl_iiot_2021.csv\"\n","  target = 'Target'\n","  drop_cols = [\"StartTime\", \"LastTime\", \"Traffic\", \"SrcAddr\", \"DstAddr\"]\n","  frac=0.1\n","elif dataset == \"B\":\n","  dataset_name = \"/content/drive/MyDrive/creditcard.csv\"\n","  target = 'Class'\n","  drop_cols = [\"Time\"]\n","  frac=0.5"],"metadata":{"id":"zNLyODO3h4nL","executionInfo":{"status":"ok","timestamp":1760957145036,"user_tz":-480,"elapsed":6,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":5,"outputs":[]},{"cell_type":"code","execution_count":6,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":7858,"status":"ok","timestamp":1760957156349,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"tqQUooD0aAPH","outputId":"d088cd5f-8141-479c-e926-95c70e10c221"},"outputs":[{"output_type":"stream","name":"stdout","text":["Original dataset shape: (284807, 30), anomaly ratio=0.1727%\n","Sampled dataset shape: (142404, 30), anomaly ratio=0.1727%\n"]},{"output_type":"stream","name":"stderr","text":["/tmp/ipython-input-2184620091.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n","  .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n"]},{"output_type":"stream","name":"stdout","text":["Train shape: (75948, 30), anomaly ratio=0.1725%\n","Valid shape: (37975, 30), anomaly ratio=0.1738%\n","Test shape:  (28481, 30),  anomaly ratio=0.1720%\n","['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']\n","['Set']\n","[]\n"]}],"source":["df = pd.read_csv(dataset_name)\n","\n","df = df.drop(columns=[c for c in drop_cols if c in df.columns])\n","\n","print(f\"Original dataset shape: {df.shape}, anomaly ratio={df[target].mean():.4%}\")\n","\n","# Stratified sampling\n","df_sampled = stratified_sample(df, target, frac=frac, random_state=0)\n","print(f\"Sampled dataset shape: {df_sampled.shape}, anomaly ratio={df_sampled[target].mean():.4%}\")\n","\n","df_sampled = df_sampled.reset_index(drop=True)\n","\n","features = df_sampled.columns\n","\n","train_df, test_df = train_test_split(\n","    df_sampled, test_size=0.2, stratify=df_sampled[target], random_state=0\n",")\n","\n","train_df, valid_df = train_test_split(\n","    train_df, test_size= 0.2 / 0.6, stratify=train_df[target], random_state=0\n",")\n","\n","print(f\"Train shape: {train_df.shape}, anomaly ratio={train_df[target].mean():.4%}\")\n","print(f\"Valid shape: {valid_df.shape}, anomaly ratio={valid_df[target].mean():.4%}\")\n","print(f\"Test shape:  {test_df.shape},  anomaly ratio={test_df[target].mean():.4%}\")\n","\n","# Add the \"Set\" column\n","train_df[\"Set\"] = \"train\"\n","valid_df[\"Set\"] = \"valid\"\n","test_df[\"Set\"] = \"test\"\n","\n","# Combine them back together\n","train = pd.concat([train_df, valid_df, test_df]).reset_index(drop=True)\n","\n","train_indices = train[train.Set == \"train\"].index\n","valid_indices = train[train.Set == \"valid\"].index\n","test_indices = train[train.Set == \"test\"].index\n","\n","\n","categorical_columns = []\n","categorical_dims = {}\n","\n","nunique = train.nunique()\n","types = train.dtypes\n","\n","for col in train.columns:\n","    if types[col] == 'object':\n","        l_enc = LabelEncoder()\n","        train[col] = train[col].fillna(\"VV_likely\")\n","        train[col] = l_enc.fit_transform(train[col].values)\n","        categorical_columns.append(col)\n","        categorical_dims[col] = len(l_enc.classes_)\n","    else:\n","        train.fillna(train.loc[train_indices, col].mean(), inplace=True)\n","\n","unused_feat = [\"Set\"]\n","\n","features = [col for col in df_sampled.columns if col not in unused_feat + [target]]\n","\n","print(features)\n","\n","cat_idxs = [i for i, f in enumerate(features) if f in categorical_columns]\n","\n","cat_dims = [categorical_dims[f] for i, f in enumerate(features) if f in categorical_columns]\n","\n","print(categorical_columns)\n","print(cat_dims)"]},{"cell_type":"code","execution_count":7,"metadata":{"executionInfo":{"elapsed":2,"status":"ok","timestamp":1760957160058,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"c-yxDUQHxt6F"},"outputs":[],"source":["target_enc = LabelEncoder()\n","train[target] = target_enc.fit_transform(train[target].values)"]},{"cell_type":"code","execution_count":8,"metadata":{"executionInfo":{"elapsed":2,"status":"ok","timestamp":1760957161767,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"oXFTqW5IblTA"},"outputs":[],"source":["X_train = train[features].values[train_indices]\n","y_train = train[target].values[train_indices]\n","\n","X_valid = train[features].values[valid_indices]\n","y_valid = train[target].values[valid_indices]\n","\n","X_test = train[features].values[test_indices]\n","y_test = train[target].values[test_indices]"]},{"cell_type":"code","execution_count":9,"metadata":{"executionInfo":{"elapsed":79,"status":"ok","timestamp":1760957163748,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"XEizQZmXgxQm"},"outputs":[],"source":["# Split the data into categorical and continuous parts\n","X_train_categ = torch.tensor(X_train[:, cat_idxs], dtype=torch.long)\n","X_train_cont = torch.tensor(np.delete(X_train, cat_idxs, axis=1), dtype=torch.float32)\n","y_train_tensor = torch.tensor(y_train, dtype=torch.long)\n","\n","X_valid_categ = torch.tensor(X_valid[:, cat_idxs], dtype=torch.long)\n","X_valid_cont = torch.tensor(np.delete(X_valid, cat_idxs, axis=1), dtype=torch.float32)\n","y_valid_tensor = torch.tensor(y_valid, dtype=torch.long)\n","\n","X_test_categ = torch.tensor(X_test[:, cat_idxs], dtype=torch.long)\n","X_test_cont = torch.tensor(np.delete(X_test, cat_idxs, axis=1), dtype=torch.float32)\n","y_test_tensor = torch.tensor(y_test, dtype=torch.long)\n","\n","# Create DataLoaders\n","train_dataset = TensorDataset(X_train_categ, X_train_cont, y_train_tensor)\n","train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n","\n","valid_dataset = TensorDataset(X_valid_categ, X_valid_cont, y_valid_tensor)\n","valid_loader = DataLoader(valid_dataset, batch_size=32, shuffle=False)\n","\n","test_dataset = TensorDataset(X_test_categ, X_test_cont, y_test_tensor)\n","test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)"]},{"cell_type":"markdown","metadata":{"id":"6t0AMSr8y2Pe"},"source":["======================================================================"]},{"cell_type":"markdown","metadata":{"id":"Lbv9mESCyQNX"},"source":["==================================Model================================"]},{"cell_type":"code","execution_count":10,"metadata":{"executionInfo":{"elapsed":58,"status":"ok","timestamp":1760957165909,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"t9qv3vmlzpQx"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","\n","from einops import rearrange"]},{"cell_type":"code","execution_count":52,"metadata":{"executionInfo":{"elapsed":3,"status":"ok","timestamp":1760962981513,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"5UmJ2xwyy-AA"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","from einops import rearrange, repeat\n","\n","# ---------- Feedforward block ----------\n","class GEGLU(nn.Module):\n","    def forward(self, x):\n","        x, gates = x.chunk(2, dim=-1)\n","        return x * F.gelu(gates)\n","\n","def FeedForward(dim, mult=4, dropout=0.):\n","    return nn.Sequential(\n","        nn.LayerNorm(dim),\n","        nn.Linear(dim, dim * mult * 2),\n","        GEGLU(),\n","        nn.Dropout(dropout),\n","        nn.Linear(dim * mult, dim)\n","    )\n","\n","# ---------- Base Attention ----------\n","class Attention(nn.Module):\n","    def __init__(self, dim, heads=8, dim_head=64, dropout=0.):\n","        super().__init__()\n","        inner_dim = dim_head * heads\n","        self.heads = heads\n","        self.scale = dim_head ** -0.5\n","\n","        self.norm = nn.LayerNorm(dim)\n","        self.to_qkv = nn.Linear(dim, inner_dim * 3, bias=False)\n","        self.to_out = nn.Linear(inner_dim, dim, bias=False)\n","        self.dropout = nn.Dropout(dropout)\n","\n","    def forward(self, x):\n","        h = self.heads\n","        x = self.norm(x)\n","        q, k, v = self.to_qkv(x).chunk(3, dim=-1)\n","        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h=h), (q, k, v))\n","        q = q * self.scale\n","        sim = einsum('b h i d, b h j d -> b h i j', q, k)\n","        attn = sim.softmax(dim=-1)\n","        attn = self.dropout(attn)\n","        out = einsum('b h i j, b h j d -> b h i d', attn, v)\n","        out = rearrange(out, 'b h n d -> b n (h d)', h=h)\n","        out = self.to_out(out)\n","        return out, attn\n","\n","# ---------- MoE Attention ----------\n","class MoEAttention(nn.Module):\n","    def __init__(self, dim, num_experts=4, heads=8, dim_head=64, dropout=0.):\n","        super().__init__()\n","        self.num_experts = num_experts\n","        self.experts = nn.ModuleList([\n","            Attention(dim, heads=heads, dim_head=dim_head, dropout=dropout)\n","            for _ in range(num_experts)\n","        ])\n","        # gating network – learns routing weights\n","        self.gate = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.Linear(dim, num_experts),\n","            nn.Softmax(dim=-1)\n","        )\n","\n","    def forward(self, x):\n","        # gate per sample (batch-level)\n","        gate_weights = self.gate(x.mean(dim=1))           # (B, num_experts)\n","        expert_outputs, attn_maps = [], []\n","\n","        for expert in self.experts:\n","            out, attn = expert(x)\n","            expert_outputs.append(out)\n","            attn_maps.append(attn)\n","\n","        # weighted combine of expert outputs\n","        out = sum(w[:, None, None] * e for w, e in zip(gate_weights.T, expert_outputs))\n","        return out, attn_maps, gate_weights\n","\n","# ---------- Transformer with MoE ----------\n","class Transformer(nn.Module):\n","    def __init__(self, dim, depth, heads, dim_head, attn_dropout, ff_dropout, use_moe=False, num_experts=4):\n","        super().__init__()\n","        self.layers = nn.ModuleList([])\n","        for _ in range(depth):\n","            attn_layer = MoEAttention(dim, num_experts=num_experts, heads=heads, dim_head=dim_head, dropout=attn_dropout) \\\n","                if use_moe else Attention(dim, heads=heads, dim_head=dim_head, dropout=attn_dropout)\n","            self.layers.append(nn.ModuleList([\n","                attn_layer,\n","                FeedForward(dim, dropout=ff_dropout),\n","            ]))\n","        self.use_moe = use_moe\n","\n","    def forward(self, x, return_attn=False):\n","        attn_info = []\n","        for attn, ff in self.layers:\n","            if self.use_moe:\n","                attn_out, attn_maps, gate_weights = attn(x)\n","                attn_info.append((attn_maps, gate_weights))\n","            else:\n","                attn_out, attn_maps = attn(x)\n","                attn_info.append(attn_maps)\n","            x = attn_out + x\n","            x = ff(x) + x\n","        if not return_attn:\n","            return x\n","        return x, attn_info\n","\n","# ---------- Numeric MLP ----------\n","class NumericMLP(nn.Module):\n","    def __init__(self, num_numeric_features, dim, hidden_dims=[64, 64]):\n","        super().__init__()\n","        layers = []\n","        input_dim = num_numeric_features\n","        for h_dim in hidden_dims:\n","            layers.append(nn.Linear(input_dim, h_dim))\n","            layers.append(nn.BatchNorm1d(h_dim))\n","            layers.append(nn.ReLU())\n","            layers.append(nn.Dropout(0.1))\n","            input_dim = h_dim\n","        layers.append(nn.Linear(input_dim, dim))\n","        self.mlp = nn.Sequential(*layers)\n","\n","    def forward(self, x):\n","        return self.mlp(x)\n","\n","# ---------- Full FTTransformerFusion-MoE ----------\n","class FTTransformerFusionMoE(nn.Module):\n","    def __init__(\n","        self,\n","        *,\n","        categories,\n","        num_continuous,\n","        dim,\n","        depth,\n","        heads,\n","        dim_head=16,\n","        dim_out=1,\n","        num_special_tokens=2,\n","        attn_dropout=0.,\n","        ff_dropout=0.,\n","        mlp_hidden_dims=[64, 64],\n","        use_moe=True,\n","        num_experts=4\n","    ):\n","        super().__init__()\n","        self.num_categories = len(categories)\n","        self.num_unique_categories = sum(categories)\n","        self.num_special_tokens = num_special_tokens\n","        total_tokens = self.num_unique_categories + num_special_tokens\n","\n","        if self.num_unique_categories > 0:\n","            categories_offset = F.pad(torch.tensor(list(categories)), (1, 0), value=num_special_tokens)\n","            categories_offset = categories_offset.cumsum(dim=-1)[:-1]\n","            self.register_buffer('categories_offset', categories_offset)\n","            self.categorical_embeds = nn.Embedding(total_tokens, dim)\n","\n","        self.num_continuous = num_continuous\n","        if self.num_continuous > 0:\n","            self.numeric_mlp = NumericMLP(num_continuous, dim, mlp_hidden_dims)\n","\n","        self.cls_token = nn.Parameter(torch.randn(1, 1, dim))\n","\n","        # 🔥 Transformer with MoE Attention\n","        self.transformer = Transformer(\n","            dim=dim,\n","            depth=depth,\n","            heads=heads,\n","            dim_head=dim_head,\n","            attn_dropout=attn_dropout,\n","            ff_dropout=ff_dropout,\n","            use_moe=use_moe,\n","            num_experts=num_experts\n","        )\n","\n","        self.to_logits = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.ReLU(),\n","            nn.Linear(dim, dim_out)\n","        )\n","\n","    def forward(self, x_categ, x_numer, return_attn=False):\n","        xs = []\n","        num_residual = None\n","\n","        if self.num_unique_categories > 0:\n","            x_categ = x_categ + self.categories_offset\n","            x_categ = self.categorical_embeds(x_categ)\n","            xs.append(x_categ)\n","\n","        if self.num_continuous > 0:\n","            x_numer_emb = self.numeric_mlp(x_numer)\n","            num_residual = x_numer_emb\n","            x_numer_emb = x_numer_emb.unsqueeze(1)\n","            xs.append(x_numer_emb)\n","\n","        x = torch.cat(xs, dim=1)\n","        b = x.shape[0]\n","        cls_tokens = repeat(self.cls_token, '1 1 d -> b 1 d', b=b)\n","        x = torch.cat((cls_tokens, x), dim=1)\n","\n","        x, attn_info = self.transformer(x, return_attn=True)\n","        x = x[:, 0]\n","        if num_residual is not None:\n","            x = x + 0.2 * num_residual\n","        logits = self.to_logits(x)\n","\n","        if not return_attn:\n","            return logits\n","        return logits, attn_info"]},{"cell_type":"markdown","metadata":{"id":"GQbua9hnyb3t"},"source":["======================================================================="]},{"cell_type":"code","source":["device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")"],"metadata":{"id":"xw2OxaMb9nHI","executionInfo":{"status":"ok","timestamp":1760962872590,"user_tz":-480,"elapsed":2,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":49,"outputs":[]},{"cell_type":"code","execution_count":53,"metadata":{"executionInfo":{"elapsed":4,"status":"ok","timestamp":1760962982004,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"GP2nhw8Hx73H"},"outputs":[],"source":["model = FTTransformerFusionMoE(\n","    categories=cat_dims,           # [] for creditcard.csv\n","    num_continuous=len(features) - len(cat_dims),\n","    dim=32,\n","    depth=4,\n","    heads=8,\n","    dim_head=16,\n","    dim_out=1,\n","    attn_dropout=0.1,\n","    ff_dropout=0.1,\n","    use_moe=True,                  # enable mixture of experts\n","    num_experts=4                  # tune 2–4 for your dataset\n",").to(device)"]},{"cell_type":"code","source":["import torch\n","import torch.nn.functional as F\n","from torch import nn\n","\n","class FocalLoss(nn.Module):\n","    \"\"\"\n","    Focal Loss for binary classification.\n","    Helps models focus on hard, minority examples.\n","    \"\"\"\n","    def __init__(self, alpha=5.0, gamma=2.0, reduction='mean'):\n","        super().__init__()\n","        self.alpha = alpha\n","        self.gamma = gamma\n","        self.reduction = reduction\n","\n","    def forward(self, logits, targets):\n","        \"\"\"\n","        logits: (batch,) or (batch, 1) raw model outputs\n","        targets: (batch,) binary labels 0 or 1\n","        \"\"\"\n","        targets = targets.float().view(-1, 1)\n","        logits = logits.view(-1, 1)\n","\n","        bce_loss = F.binary_cross_entropy_with_logits(logits, targets, reduction='none')\n","        pt = torch.exp(-bce_loss)  # probability of the correct class\n","        focal_term = self.alpha * (1 - pt) ** self.gamma * bce_loss\n","\n","        if self.reduction == 'mean':\n","            return focal_term.mean()\n","        elif self.reduction == 'sum':\n","            return focal_term.sum()\n","        return focal_term"],"metadata":{"id":"ENC6o4HZTGAU","executionInfo":{"status":"ok","timestamp":1760962928497,"user_tz":-480,"elapsed":2,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":51,"outputs":[]},{"cell_type":"code","execution_count":54,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OquETEtzzZ-V","executionInfo":{"status":"ok","timestamp":1760964930297,"user_tz":-480,"elapsed":1940394,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"6205299e-3b2e-4c52-d0f4-b3f9690c73ad"},"outputs":[{"output_type":"stream","name":"stdout","text":["Epoch 01 | Loss=0.0249 | Val F1=0.7009 | Thr=0.22 | Avg Gates: [g0:0.08, g1:0.40, g2:0.15, g3:0.37]\n","Epoch 02 | Loss=0.0080 | Val F1=0.7317 | Thr=0.14 | Avg Gates: [g0:0.08, g1:0.44, g2:0.12, g3:0.36]\n","Epoch 03 | Loss=0.0066 | Val F1=0.7377 | Thr=0.16 | Avg Gates: [g0:0.06, g1:0.52, g2:0.09, g3:0.34]\n","Epoch 04 | Loss=0.0071 | Val F1=0.7049 | Thr=0.11 | Avg Gates: [g0:0.04, g1:0.37, g2:0.08, g3:0.52]\n","Epoch 05 | Loss=0.0075 | Val F1=0.7317 | Thr=0.11 | Avg Gates: [g0:0.04, g1:0.28, g2:0.09, g3:0.58]\n","Epoch 06 | Loss=0.0066 | Val F1=0.7500 | Thr=0.08 | Avg Gates: [g0:0.01, g1:0.15, g2:0.04, g3:0.79]\n","Epoch 07 | Loss=0.0072 | Val F1=0.7520 | Thr=0.10 | Avg Gates: [g0:0.01, g1:0.11, g2:0.03, g3:0.85]\n","Epoch 08 | Loss=0.0072 | Val F1=0.7009 | Thr=0.50 | Avg Gates: [g0:0.02, g1:0.05, g2:0.03, g3:0.90]\n","Epoch 09 | Loss=0.0066 | Val F1=0.7317 | Thr=0.11 | Avg Gates: [g0:0.03, g1:0.03, g2:0.02, g3:0.92]\n","Epoch 10 | Loss=0.0069 | Val F1=0.7500 | Thr=0.22 | Avg Gates: [g0:0.03, g1:0.05, g2:0.03, g3:0.89]\n","Epoch 11 | Loss=0.0058 | Val F1=0.7559 | Thr=0.27 | Avg Gates: [g0:0.08, g1:0.10, g2:0.05, g3:0.77]\n","Epoch 12 | Loss=0.0055 | Val F1=0.7500 | Thr=0.25 | Avg Gates: [g0:0.04, g1:0.07, g2:0.03, g3:0.86]\n","Epoch 13 | Loss=0.0053 | Val F1=0.7500 | Thr=0.22 | Avg Gates: [g0:0.03, g1:0.07, g2:0.02, g3:0.88]\n","Epoch 14 | Loss=0.0055 | Val F1=0.7500 | Thr=0.10 | Avg Gates: [g0:0.03, g1:0.07, g2:0.02, g3:0.88]\n","Epoch 15 | Loss=0.0054 | Val F1=0.7500 | Thr=0.38 | Avg Gates: [g0:0.06, g1:0.08, g2:0.03, g3:0.83]\n","Epoch 16 | Loss=0.0052 | Val F1=0.7500 | Thr=0.19 | Avg Gates: [g0:0.07, g1:0.09, g2:0.04, g3:0.81]\n","Epoch 17 | Loss=0.0047 | Val F1=0.7500 | Thr=0.31 | Avg Gates: [g0:0.05, g1:0.08, g2:0.04, g3:0.82]\n","Epoch 18 | Loss=0.0046 | Val F1=0.7500 | Thr=0.17 | Avg Gates: [g0:0.05, g1:0.08, g2:0.04, g3:0.83]\n","Epoch 19 | Loss=0.0046 | Val F1=0.7500 | Thr=0.28 | Avg Gates: [g0:0.07, g1:0.09, g2:0.04, g3:0.80]\n","Epoch 20 | Loss=0.0045 | Val F1=0.7500 | Thr=0.33 | Avg Gates: [g0:0.06, g1:0.09, g2:0.04, g3:0.81]\n","\n","✅ Best Validation F1: 0.7559 at threshold=0.27\n"]}],"source":["from sklearn.metrics import f1_score\n","import numpy as np\n","import torch\n","\n","# --- Optimizer + Scheduler ---\n","optimizer = torch.optim.AdamW(model.parameters(), lr=1e-3, weight_decay=1e-2)\n","scheduler = torch.optim.lr_scheduler.OneCycleLR(\n","    optimizer, max_lr=1e-3, steps_per_epoch=len(train_loader), epochs=20\n",")\n","\n","# --- Loss Function ---\n","criterion = FocalLoss(alpha=5.0, gamma=2.0)\n","\n","# --- Training ---\n","best_val_f1, best_model_state, best_threshold = 0.0, None, 0.5\n","\n","for epoch in range(1, 21):\n","    model.train()\n","    total_loss = 0.0\n","\n","    for x_cat, x_num, y in train_loader:\n","        x_cat, x_num, y = x_cat.to(device), x_num.to(device), y.to(device)\n","        optimizer.zero_grad()\n","        logits = model(x_cat, x_num)\n","        loss = criterion(logits, y)\n","        loss.backward()\n","        optimizer.step()\n","        scheduler.step()\n","        total_loss += loss.item()\n","\n","    # --- Validation Phase ---\n","    model.eval()\n","    preds, labels = [], []\n","    gating_stats = []  # track average gate activations per batch (for explainability)\n","\n","    with torch.no_grad():\n","        for x_cat, x_num, y in valid_loader:\n","            x_cat, x_num = x_cat.to(device), x_num.to(device)\n","            logits, attn_info = model(x_cat, x_num, return_attn=True)\n","\n","            # collect mixture-of-experts gating info (first transformer layer)\n","            _, gate_weights = attn_info[0]  # (attn_maps, gate_weights)\n","            gating_stats.append(gate_weights.cpu().numpy())\n","\n","            probs = torch.sigmoid(logits).cpu().numpy().flatten()\n","            preds.extend(probs)\n","            labels.extend(y.numpy())\n","\n","    # --- Compute Validation F1 across thresholds ---\n","    thresholds = np.linspace(0.05, 0.5, 30)\n","    f1s = [f1_score(labels, (np.array(preds) > t).astype(int)) for t in thresholds]\n","    best_t_idx = np.argmax(f1s)\n","    val_f1, best_t = f1s[best_t_idx], thresholds[best_t_idx]\n","\n","    if val_f1 > best_val_f1:\n","        best_val_f1 = val_f1\n","        best_model_state = model.state_dict()\n","        best_threshold = best_t\n","\n","    avg_gate = np.mean(np.concatenate(gating_stats, axis=0), axis=0)\n","    gate_str = \", \".join([f\"g{i}:{w:.2f}\" for i, w in enumerate(avg_gate)])\n","\n","    print(\n","        f\"Epoch {epoch:02d} | \"\n","        f\"Loss={total_loss/len(train_loader):.4f} | \"\n","        f\"Val F1={val_f1:.4f} | Thr={best_t:.2f} | \"\n","        f\"Avg Gates: [{gate_str}]\"\n","    )\n","\n","# --- Save best model ---\n","model.load_state_dict(best_model_state)\n","print(f\"\\n✅ Best Validation F1: {best_val_f1:.4f} at threshold={best_threshold:.2f}\")"]},{"cell_type":"code","source":["print(test_df[target].value_counts())\n","print(\"\\nAnomaly ratio:\", test_df[target].mean())"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"1oYHYVtui09U","executionInfo":{"status":"ok","timestamp":1760964936662,"user_tz":-480,"elapsed":4,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"444f5a05-698a-4aa0-bd19-101445259749"},"execution_count":55,"outputs":[{"output_type":"stream","name":"stdout","text":["Class\n","0    28432\n","1       49\n","Name: count, dtype: int64\n","\n","Anomaly ratio: 0.0017204452090867595\n"]}]},{"cell_type":"code","execution_count":56,"metadata":{"id":"0_u9H5FB55j0","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1760964949082,"user_tz":-480,"elapsed":9971,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"e758e4b6-403e-486b-b7c7-65cfd3ca0ec3"},"outputs":[{"output_type":"stream","name":"stdout","text":["Preds: 28481 Labels: 28481\n","Test F1: 0.7920792079207921\n"]}],"source":["# 5️⃣ Final test evaluation\n","model.eval()\n","test_probs = []\n","\n","with torch.no_grad():\n","    for x_categ, x_cont, _ in test_loader:\n","        x_categ = x_categ.to(device)\n","        x_cont = x_cont.to(device)\n","        logits = model(x_cat, x_cont)\n","        test_probs.extend(torch.sigmoid(logits).cpu().numpy().flatten())\n","\n","# Ensure same length as y_test\n","print(\"Preds:\", len(test_probs), \"Labels:\", len(y_test))\n","\n","# F1 computation\n","y_pred = (np.array(test_probs) > best_t).astype(int)\n","test_f1 = f1_score(y_test, y_pred)\n","print(\"Test F1:\", test_f1)"]},{"cell_type":"code","execution_count":57,"metadata":{"id":"zGZ9KqXK0AiS","colab":{"base_uri":"https://localhost:8080/","height":472},"executionInfo":{"status":"ok","timestamp":1760964953496,"user_tz":-480,"elapsed":14,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"87577883-94bb-4171-af7f-21bad6cf2b4d"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# Confusion Matrix\n","cm = confusion_matrix(y_test, y_pred)\n","disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n","disp.plot(cmap=plt.cm.Blues)\n","plt.title(\"Confusion Matrix\")\n","plt.show()"]},{"cell_type":"code","source":["# Accuracy, Precision, Recall, F1-Score\n","accuracy = accuracy_score(y_test, y_pred)\n","precision = precision_score(y_test, y_pred)\n","recall = recall_score(y_test, y_pred)\n","f1 = f1_score(y_test, y_pred)\n","auc = roc_auc_score(y_test, y_pred)\n","\n","\n","# Print individual scores\n","print(f\"Accuracy: {accuracy:.4f}\")\n","print(f\"Precision: {precision:.4f}\")\n","print(f\"Recall: {recall:.4f}\")\n","print(f\"F1-Score: {f1:.4f}\")\n","print(f\"ROC-AUC: {auc:.4f}\")\n","\n","# Classification report for a detailed overview\n","print(classification_report(y_test, y_pred))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"VhO2p17A9x-K","executionInfo":{"status":"ok","timestamp":1760964957389,"user_tz":-480,"elapsed":26,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"77a38e5c-9797-4c18-e850-d54af8b467cb"},"execution_count":58,"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 0.9993\n","Precision: 0.7692\n","Recall: 0.8163\n","F1-Score: 0.7921\n","ROC-AUC: 0.9080\n","              precision    recall  f1-score   support\n","\n","           0       1.00      1.00      1.00     28432\n","           1       0.77      0.82      0.79        49\n","\n","    accuracy                           1.00     28481\n","   macro avg       0.88      0.91      0.90     28481\n","weighted avg       1.00      1.00      1.00     28481\n","\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"zOAg6qHesSdz"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"gpuType":"T4","authorship_tag":"ABX9TyPvwkcWp0ALlqiuodw7ONmH"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"},"accelerator":"GPU"},"nbformat":4,"nbformat_minor":0}