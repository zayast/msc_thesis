{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"executionInfo":{"elapsed":6223,"status":"ok","timestamp":1760968102846,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"QYO-HYkgZ4T3"},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import pandas as pd\n","import numpy as np\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import accuracy_score\n","from torch.utils.data import DataLoader, TensorDataset\n","from torch.optim import Adam\n","from sklearn.model_selection import train_test_split\n","import matplotlib.pyplot as plt"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"VdpcwaM9z4TN","executionInfo":{"status":"ok","timestamp":1760968102852,"user_tz":-480,"elapsed":2,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"outputs":[],"source":["from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay\n","from sklearn.metrics import precision_score, recall_score, f1_score, classification_report\n","from sklearn.metrics import roc_auc_score, precision_recall_curve, f1_score"]},{"cell_type":"code","execution_count":4,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":27644,"status":"ok","timestamp":1760968161598,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"7lEomYw8aQbh","outputId":"ec6c9738-2d07-40d6-a360-1bfa16bbcca7"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"markdown","metadata":{"id":"5Q9MHkvXys9q"},"source":["=====================Data prepration============================="]},{"cell_type":"code","execution_count":5,"metadata":{"executionInfo":{"elapsed":28,"status":"ok","timestamp":1760968240608,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"JEb6Fm_HcbCy"},"outputs":[],"source":["# -----------------\n","# Helper: stratified sampling\n","# -----------------\n","def stratified_sample(df, target_col, frac=None, n=None, random_state=42):\n","    \"\"\"Return stratified sample keeping target ratio\"\"\"\n","    if frac is not None:\n","        df_sampled = df.groupby(target_col, group_keys=False)\\\n","                       .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n","    elif n is not None:\n","        class_counts = df[target_col].value_counts()\n","        total = class_counts.sum()\n","        df_sampled = []\n","        for c, count in class_counts.items():\n","            take = int(n * (count / total))\n","            df_sampled.append(df[df[target_col] == c].sample(n=take, random_state=random_state))\n","        df_sampled = pd.concat(df_sampled)\n","    else:\n","        df_sampled = df\n","    return df_sampled.sample(frac=1.0, random_state=random_state).reset_index(drop=True)"]},{"cell_type":"code","source":["dataset = \"B\"\n","\n","if dataset == \"A\":\n","  dataset_name = \"/content/drive/MyDrive/wustl_iiot_2021.csv\"\n","  target = 'Target'\n","  drop_cols = [\"StartTime\", \"LastTime\", \"Traffic\", \"SrcAddr\", \"DstAddr\"]\n","  frac=0.1\n","elif dataset == \"B\":\n","  dataset_name = \"/content/drive/MyDrive/creditcard.csv\"\n","  target = 'Class'\n","  drop_cols = [\"Time\"]\n","  frac=0.5"],"metadata":{"id":"zNLyODO3h4nL","executionInfo":{"status":"ok","timestamp":1760968242810,"user_tz":-480,"elapsed":14,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":6,"outputs":[]},{"cell_type":"code","execution_count":36,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":2159,"status":"ok","timestamp":1760969049621,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"tqQUooD0aAPH","outputId":"6e39cdb1-404f-4bbe-ff7b-75768598417c"},"outputs":[{"output_type":"stream","name":"stdout","text":["Original dataset shape: (284807, 30), anomaly ratio=0.1727%\n","Sampled dataset shape: (142404, 30), anomaly ratio=0.1727%\n","Train shape: (75948, 30), anomaly ratio=0.1725%\n","Valid shape: (37975, 30), anomaly ratio=0.1738%\n","Test shape:  (28481, 30),  anomaly ratio=0.1720%\n"]},{"output_type":"stream","name":"stderr","text":["/tmp/ipython-input-2184620091.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n","  .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n"]}],"source":["df = pd.read_csv(dataset_name)\n","\n","df = df.drop(columns=[c for c in drop_cols if c in df.columns])\n","\n","print(f\"Original dataset shape: {df.shape}, anomaly ratio={df[target].mean():.4%}\")\n","\n","# Stratified sampling\n","df_sampled = stratified_sample(df, target, frac=frac, random_state=0)\n","print(f\"Sampled dataset shape: {df_sampled.shape}, anomaly ratio={df_sampled[target].mean():.4%}\")\n","\n","df_sampled = df_sampled.reset_index(drop=True)\n","\n","features = df_sampled.columns\n","\n","train_df, test_df = train_test_split(\n","    df_sampled, test_size=0.2, stratify=df_sampled[target], random_state=0\n",")\n","\n","train_df, valid_df = train_test_split(\n","    train_df, test_size= 0.2 / 0.6, stratify=train_df[target], random_state=0\n",")\n","\n","print(f\"Train shape: {train_df.shape}, anomaly ratio={train_df[target].mean():.4%}\")\n","print(f\"Valid shape: {valid_df.shape}, anomaly ratio={valid_df[target].mean():.4%}\")\n","print(f\"Test shape:  {test_df.shape},  anomaly ratio={test_df[target].mean():.4%}\")\n","\n","# Add the \"Set\" column\n","train_df[\"Set\"] = \"train\"\n","valid_df[\"Set\"] = \"valid\"\n","test_df[\"Set\"] = \"test\""]},{"cell_type":"code","source":["import numpy as np\n","from sklearn.preprocessing import StandardScaler\n","\n","for df in [train_df, valid_df, test_df]:\n","    df[\"Log_Amount\"] = np.log1p(df[\"Amount\"])   # log(Amount + 1)\n","\n","scaler = StandardScaler()\n","train_df[\"Amount_Scaled\"] = scaler.fit_transform(train_df[[\"Log_Amount\"]])\n","valid_df[\"Amount_Scaled\"] = scaler.transform(valid_df[[\"Log_Amount\"]])\n","test_df[\"Amount_Scaled\"] = scaler.transform(test_df[[\"Log_Amount\"]])\n","\n","train_df = train_df.drop(columns=[\"Amount\", \"Log_Amount\"])\n","valid_df = valid_df.drop(columns=[\"Amount\", \"Log_Amount\"])\n","test_df = test_df.drop(columns=[\"Amount\", \"Log_Amount\"])"],"metadata":{"id":"ZDq8_jiO4x21","executionInfo":{"status":"ok","timestamp":1760969062677,"user_tz":-480,"elapsed":3,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":37,"outputs":[]},{"cell_type":"code","source":["\n","# Combine them back together\n","train = pd.concat([train_df, valid_df, test_df]).reset_index(drop=True)\n","\n","train_indices = train[train.Set == \"train\"].index\n","valid_indices = train[train.Set == \"valid\"].index\n","test_indices = train[train.Set == \"test\"].index\n","\n","\n","categorical_columns = []\n","numerical_columns = []\n","categorical_dims = {}\n","\n","nunique = train.nunique()\n","types = train.dtypes\n","\n","for col in train.columns:\n","    if col == target or col == 'Set':\n","        continue\n","    if types[col] == 'object':\n","        l_enc = LabelEncoder()\n","        train[col] = train[col].fillna(\"VV_likely\")\n","        train[col] = l_enc.fit_transform(train[col].values)\n","        categorical_columns.append(col)\n","        categorical_dims[col] = len(l_enc.classes_)\n","    else:\n","        train.fillna(train.loc[train_indices, col].mean(), inplace=True)\n","        numerical_columns.append(col)\n","\n","unused_feat = [\"Set\"]\n","\n","features = [col for col in train.columns if col not in unused_feat + [target]]\n","\n","print(features)\n","print(\"Categorical columns:\", categorical_columns)\n","print(\"Numerical columns:\", numerical_columns)\n","\n","cat_idxs = [i for i, f in enumerate(features) if f in categorical_columns]\n","\n","print(cat_idxs)\n","cat_dims = [categorical_dims[f] for i, f in enumerate(features) if f in categorical_columns]\n","print(cat_dims)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"V9NYpUa95GFk","executionInfo":{"status":"ok","timestamp":1760969077357,"user_tz":-480,"elapsed":542,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"03201f56-989b-4567-d86e-99cb1e7a2597"},"execution_count":38,"outputs":[{"output_type":"stream","name":"stdout","text":["['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount_Scaled']\n","Categorical columns: []\n","Numerical columns: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount_Scaled']\n","[]\n","[]\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"w0ZNnd4y5zrl"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["from scipy.stats import skew\n","import numpy as np\n","import pandas as pd\n","\n","def auto_split_numerical_features(X, skew_threshold=1.0, unique_threshold=10):\n","    binned_cols, linear_cols = [], []\n","\n","    for col in X.columns:\n","        vals = X[col].dropna().values\n","\n","        # skip constant columns\n","        if np.unique(vals).size < 2:\n","            binned_cols.append(col)\n","            continue\n","\n","        col_skew = skew(vals)\n","        unique_vals = np.unique(vals).size\n","\n","        if abs(col_skew) > skew_threshold or unique_vals <= unique_threshold:\n","            binned_cols.append(col)\n","        else:\n","            linear_cols.append(col)\n","\n","    return binned_cols, linear_cols\n","\n","binned_cols, linear_cols = auto_split_numerical_features(train[numerical_columns])\n","\n","print(\"Binned columns:\", binned_cols)\n","print(\"Linear columns:\", linear_cols)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"5vJxd1kAod9a","executionInfo":{"status":"ok","timestamp":1760969086273,"user_tz":-480,"elapsed":436,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"b41ff66a-ad4d-4450-f204-dc47615cc515"},"execution_count":39,"outputs":[{"output_type":"stream","name":"stdout","text":["Binned columns: ['V1', 'V2', 'V3', 'V6', 'V7', 'V8', 'V10', 'V12', 'V14', 'V16', 'V17', 'V21', 'V23', 'V27', 'V28']\n","Linear columns: ['V4', 'V5', 'V9', 'V11', 'V13', 'V15', 'V18', 'V19', 'V20', 'V22', 'V24', 'V25', 'V26', 'Amount_Scaled']\n"]}]},{"cell_type":"code","source":["train.head(1)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":110},"id":"0i0G4NNh8JD0","executionInfo":{"status":"ok","timestamp":1760969145749,"user_tz":-480,"elapsed":39,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"8e0afd53-1212-4ccb-bb56-57f32305f116"},"execution_count":44,"outputs":[{"output_type":"execute_result","data":{"text/plain":["         V1       V2        V3        V4        V5        V6       V7  \\\n","0 -1.191979  0.36565 -0.851446 -0.055588  0.660455 -0.897988  0.91759   \n","\n","         V8        V9       V10  ...       V22       V23       V24       V25  \\\n","0 -1.093202 -0.003047 -0.314985  ...  1.008052  0.559219 -0.048767 -0.188407   \n","\n","        V26       V27       V28  Class    Set  Amount_Scaled  \n","0 -0.133896  0.385091  0.149272      0  train       0.875533  \n","\n","[1 rows x 31 columns]"],"text/html":["\n","  <div id=\"df-f86857ed-3cc0-458a-a7ff-4a0bbfb966b0\" class=\"colab-df-container\">\n","    <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>V1</th>\n","      <th>V2</th>\n","      <th>V3</th>\n","      <th>V4</th>\n","      <th>V5</th>\n","      <th>V6</th>\n","      <th>V7</th>\n","      <th>V8</th>\n","      <th>V9</th>\n","      <th>V10</th>\n","      <th>...</th>\n","      <th>V22</th>\n","      <th>V23</th>\n","      <th>V24</th>\n","      <th>V25</th>\n","      <th>V26</th>\n","      <th>V27</th>\n","      <th>V28</th>\n","      <th>Class</th>\n","      <th>Set</th>\n","      <th>Amount_Scaled</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>-1.191979</td>\n","      <td>0.36565</td>\n","      <td>-0.851446</td>\n","      <td>-0.055588</td>\n","      <td>0.660455</td>\n","      <td>-0.897988</td>\n","      <td>0.91759</td>\n","      <td>-1.093202</td>\n","      <td>-0.003047</td>\n","      <td>-0.314985</td>\n","      <td>...</td>\n","      <td>1.008052</td>\n","      <td>0.559219</td>\n","      <td>-0.048767</td>\n","      <td>-0.188407</td>\n","      <td>-0.133896</td>\n","      <td>0.385091</td>\n","      <td>0.149272</td>\n","      <td>0</td>\n","      <td>train</td>\n","      <td>0.875533</td>\n","    </tr>\n","  </tbody>\n","</table>\n","<p>1 rows × 31 columns</p>\n","</div>\n","    <div class=\"colab-df-buttons\">\n","\n","  <div class=\"colab-df-container\">\n","    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-f86857ed-3cc0-458a-a7ff-4a0bbfb966b0')\"\n","            title=\"Convert this dataframe to an interactive table.\"\n","            style=\"display:none;\">\n","\n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n","    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n","  </svg>\n","    </button>\n","\n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    .colab-df-buttons div {\n","      margin-bottom: 4px;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","    <script>\n","      const buttonEl =\n","        document.querySelector('#df-f86857ed-3cc0-458a-a7ff-4a0bbfb966b0 button.colab-df-convert');\n","      buttonEl.style.display =\n","        google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","      async function convertToInteractive(key) {\n","        const element = document.querySelector('#df-f86857ed-3cc0-458a-a7ff-4a0bbfb966b0');\n","        const dataTable =\n","          await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                    [key], {});\n","        if (!dataTable) return;\n","\n","        const docLinkHtml = 'Like what you see? Visit the ' +\n","          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","          + ' to learn more about interactive tables.';\n","        element.innerHTML = '';\n","        dataTable['output_type'] = 'display_data';\n","        await google.colab.output.renderOutput(dataTable, element);\n","        const docLink = document.createElement('div');\n","        docLink.innerHTML = docLinkHtml;\n","        element.appendChild(docLink);\n","      }\n","    </script>\n","  </div>\n","\n","\n","    </div>\n","  </div>\n"],"application/vnd.google.colaboratory.intrinsic+json":{"type":"dataframe","variable_name":"train"}},"metadata":{},"execution_count":44}]},{"cell_type":"code","execution_count":48,"metadata":{"executionInfo":{"elapsed":17,"status":"ok","timestamp":1760969287652,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"c-yxDUQHxt6F"},"outputs":[],"source":["target_enc = LabelEncoder()\n","train[target] = target_enc.fit_transform(train[target].values)"]},{"cell_type":"code","execution_count":49,"metadata":{"executionInfo":{"elapsed":31,"status":"ok","timestamp":1760969289676,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"oXFTqW5IblTA"},"outputs":[],"source":["X_train = train[features].values[train_indices]\n","y_train = train[target].values[train_indices]\n","\n","X_valid = train[features].values[valid_indices]\n","y_valid = train[target].values[valid_indices]\n","\n","X_test = train[features].values[test_indices]\n","y_test = train[target].values[test_indices]"]},{"cell_type":"code","source":["X_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"lrzMwFTWTTB8","executionInfo":{"status":"ok","timestamp":1760968988353,"user_tz":-480,"elapsed":33,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"96cba2d1-9898-49e5-bdaf-5ad818a09dee"},"execution_count":34,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([[-1.19197911e+00,  3.65650122e-01, -8.51445584e-01,\n","        -5.55876464e-02,  6.60455094e-01, -8.97987761e-01,\n","         9.17589518e-01, -1.09320231e+00, -3.04718385e-03,\n","        -3.14985028e-01,  1.37842811e+00,  5.80745705e-01,\n","         4.10150716e-02, -7.67188541e-01,  1.12237566e-01,\n","         2.29330820e-01,  2.57217208e-01,  1.05117226e+00,\n","         7.67926875e-02, -6.39738004e-01,  9.28457312e-01,\n","         1.00805213e+00,  5.59219071e-01, -4.87668841e-02,\n","        -1.88406839e-01, -1.33895716e-01,  3.85090717e-01,\n","         1.49271649e-01,  8.75533396e-01],\n","       [-1.10183428e+00,  1.42811407e+00,  1.75677727e+00,\n","         4.57016384e+00, -7.85317014e-01,  1.74108541e+00,\n","         4.60257243e-01,  4.84929055e-01, -7.22077270e-01,\n","         6.13497785e-01, -4.18485976e-01, -3.65065122e+00,\n","         1.53242701e+00,  1.78262993e+00,  7.01455562e-01,\n","         5.11940272e-01,  8.11029639e-01,  1.08387676e+00,\n","         7.74394808e-01,  1.48712822e-01,  1.01479933e-01,\n","         3.42363325e-01, -1.18869258e-01,  6.43704638e-01,\n","         1.74076932e-01,  4.92296165e-01, -9.15912795e-02,\n","        -2.42055297e-02,  1.37239419e+00]])"]},"metadata":{},"execution_count":34}]},{"cell_type":"code","source":["y_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6ZaXye2RTUKI","executionInfo":{"status":"ok","timestamp":1760968404478,"user_tz":-480,"elapsed":7,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"69fd0297-eb6c-4c3e-e5a1-dcc0c3fe78d1"},"execution_count":19,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([0, 0])"]},"metadata":{},"execution_count":19}]},{"cell_type":"code","source":["binned_idxs = [train[features].columns.get_loc(c) for c in binned_cols]\n","linear_idxs = [train[features].columns.get_loc(c) for c in linear_cols]\n","\n","print(\"Binned idxs:\", binned_idxs)\n","print(\"Linear idxs:\", linear_idxs)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"wBlXCa_i8wCy","executionInfo":{"status":"ok","timestamp":1760969350426,"user_tz":-480,"elapsed":184,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"011bc6e5-d6da-4052-c4bf-19dec2add87c"},"execution_count":51,"outputs":[{"output_type":"stream","name":"stdout","text":["Binned idxs: [0, 1, 2, 5, 6, 7, 9, 11, 13, 15, 16, 20, 22, 26, 27]\n","Linear idxs: [3, 4, 8, 10, 12, 14, 17, 18, 19, 21, 23, 24, 25, 28]\n"]}]},{"cell_type":"code","execution_count":52,"metadata":{"executionInfo":{"elapsed":30,"status":"ok","timestamp":1760969358276,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"XEizQZmXgxQm"},"outputs":[],"source":["# ---------- TRAIN ----------\n","X_train_categ = torch.tensor(X_train[:, cat_idxs], dtype=torch.long)\n","X_train_binned = torch.tensor(X_train[:, binned_idxs], dtype=torch.float32)\n","X_train_linear = torch.tensor(X_train[:, linear_idxs], dtype=torch.float32)\n","y_train_tensor = torch.tensor(y_train, dtype=torch.long)\n","\n","# ---------- VALID ----------\n","X_valid_categ = torch.tensor(X_valid[:, cat_idxs], dtype=torch.long)\n","X_valid_binned = torch.tensor(X_valid[:, binned_idxs], dtype=torch.float32)\n","X_valid_linear = torch.tensor(X_valid[:, linear_idxs], dtype=torch.float32)\n","y_valid_tensor = torch.tensor(y_valid, dtype=torch.long)\n","\n","# ---------- TEST ----------\n","X_test_categ = torch.tensor(X_test[:, cat_idxs], dtype=torch.long)\n","X_test_binned = torch.tensor(X_test[:, binned_idxs], dtype=torch.float32)\n","X_test_linear = torch.tensor(X_test[:, linear_idxs], dtype=torch.float32)\n","y_test_tensor = torch.tensor(y_test, dtype=torch.long)\n","\n","\n","\n","# Create DataLoaders\n","train_dataset = TensorDataset(X_train_categ, X_train_binned, X_train_linear, y_train_tensor)\n","train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n","\n","valid_dataset = TensorDataset(X_valid_categ, X_valid_binned, X_valid_linear, y_valid_tensor)\n","valid_loader = DataLoader(valid_dataset, batch_size=32, shuffle=False)\n","\n","test_dataset = TensorDataset(X_test_categ, X_test_binned, X_test_linear, y_test_tensor)\n","test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)"]},{"cell_type":"markdown","metadata":{"id":"6t0AMSr8y2Pe"},"source":["======================================================================"]},{"cell_type":"markdown","metadata":{"id":"Lbv9mESCyQNX"},"source":["==================================Model================================"]},{"cell_type":"code","execution_count":53,"metadata":{"executionInfo":{"elapsed":3,"status":"ok","timestamp":1760969361935,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"t9qv3vmlzpQx"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","\n","from einops import rearrange"]},{"cell_type":"code","execution_count":54,"metadata":{"executionInfo":{"elapsed":3,"status":"ok","timestamp":1760969363828,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"5UmJ2xwyy-AA"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","from einops import rearrange, repeat\n","import numpy as np\n","import pandas as pd\n","\n","\n","# ------------------------------\n","# Core building blocks\n","# ------------------------------\n","\n","class GEGLU(nn.Module):\n","    def forward(self, x):\n","        x, gates = x.chunk(2, dim=-1)\n","        return x * F.gelu(gates)\n","\n","\n","def FeedForward(dim, mult=4, dropout=0.):\n","    return nn.Sequential(\n","        nn.LayerNorm(dim),\n","        nn.Linear(dim, dim * mult * 2),\n","        GEGLU(),\n","        nn.Dropout(dropout),\n","        nn.Linear(dim * mult, dim)\n","    )\n","\n","\n","class Attention(nn.Module):\n","    def __init__(self, dim, heads=8, dim_head=64, dropout=0.):\n","        super().__init__()\n","        inner_dim = dim_head * heads\n","        self.heads = heads\n","        self.scale = dim_head ** -0.5\n","        self.norm = nn.LayerNorm(dim)\n","        self.to_qkv = nn.Linear(dim, inner_dim * 3, bias=False)\n","        self.to_out = nn.Linear(inner_dim, dim, bias=False)\n","        self.dropout = nn.Dropout(dropout)\n","\n","    def forward(self, x):\n","        h = self.heads\n","        x = self.norm(x)\n","        q, k, v = self.to_qkv(x).chunk(3, dim=-1)\n","        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h=h), (q, k, v))\n","        q = q * self.scale\n","        sim = einsum('b h i d, b h j d -> b h i j', q, k)\n","        attn = sim.softmax(dim=-1)\n","        dropped_attn = self.dropout(attn)\n","        out = einsum('b h i j, b h j d -> b h i d', dropped_attn, v)\n","        out = rearrange(out, 'b h n d -> b n (h d)', h=h)\n","        out = self.to_out(out)\n","        return out, attn\n","\n","\n","class Transformer(nn.Module):\n","    def __init__(self, dim, depth, heads, dim_head, attn_dropout, ff_dropout):\n","        super().__init__()\n","        self.layers = nn.ModuleList([\n","            nn.ModuleList([\n","                Attention(dim, heads=heads, dim_head=dim_head, dropout=attn_dropout),\n","                FeedForward(dim, dropout=ff_dropout)\n","            ])\n","            for _ in range(depth)\n","        ])\n","\n","    def forward(self, x, return_attn=False):\n","        post_softmax_attns = []\n","        for attn, ff in self.layers:\n","            attn_out, post_softmax_attn = attn(x)\n","            post_softmax_attns.append(post_softmax_attn)\n","            x = attn_out + x\n","            x = ff(x) + x\n","        if not return_attn:\n","            return x\n","        return x, torch.stack(post_softmax_attns)\n","\n","\n","# ------------------------------\n","# Automatic Binning Embedder\n","# ------------------------------\n","\n","class BinnedEmbedder(nn.Module):\n","    def __init__(self, dim, num_continuous, num_bins=32, binning='quantile'):\n","        super().__init__()\n","        self.num_continuous = num_continuous\n","        self.num_bins = num_bins\n","        self.binning = binning\n","        self.embeds = nn.ModuleList([\n","            nn.Embedding(num_bins, dim) for _ in range(num_continuous)\n","        ])\n","        self.register_buffer('bin_edges', torch.zeros(num_continuous, num_bins - 1))\n","\n","    @torch.no_grad()\n","    def fit(self, data):\n","        if isinstance(data, pd.DataFrame):\n","            data = torch.tensor(data.values, dtype=torch.float32)\n","        elif not torch.is_tensor(data):\n","            raise TypeError(\"Input must be a torch.Tensor or pandas DataFrame\")\n","\n","        edges_list = []\n","        for i in range(self.num_continuous):\n","            col = data[:, i].cpu().numpy()\n","            col = col[~np.isnan(col)]\n","\n","            unique_vals = np.unique(col)\n","            if len(unique_vals) < 2:\n","                # constant column — make dummy edges\n","                edges = np.linspace(col.min() - 1e-6, col.max() + 1e-6, self.num_bins - 1)\n","            else:\n","                if self.binning == 'quantile':\n","                    quantiles = np.linspace(0, 1, self.num_bins)\n","                    edges = np.quantile(col, quantiles)\n","                    edges = np.unique(edges)[1:-1]  # drop dupes & endpoints\n","                elif self.binning == 'uniform':\n","                    edges = np.linspace(col.min(), col.max(), self.num_bins - 1)\n","                else:\n","                    raise ValueError(\"binning must be 'quantile' or 'uniform'\")\n","\n","            # --- Safety fix ---\n","            if len(edges) < self.num_bins - 1:\n","                last = edges[-1] if len(edges) > 0 else col.max()\n","                edges = np.pad(edges, (0, self.num_bins - 1 - len(edges)), constant_values=last)\n","\n","            edges_list.append(torch.tensor(edges, dtype=torch.float32))\n","\n","        self.set_bin_edges(edges_list)\n","\n","    # ✅ Add this method\n","    def set_bin_edges(self, edges_list):\n","        \"\"\"\n","        Store computed edges into model buffer safely.\n","        \"\"\"\n","        for i, edges in enumerate(edges_list):\n","            # Make sure number of edges matches expected dimension\n","            if edges.numel() != self.num_bins - 1:\n","                # pad if shorter\n","                pad_len = (self.num_bins - 1) - edges.numel()\n","                edges = F.pad(edges, (0, pad_len), value=edges[-1])\n","            self.bin_edges[i, :len(edges)] = edges\n","\n","    def forward(self, x):\n","        all_embeds = []\n","        for i in range(self.num_continuous):\n","            edges = self.bin_edges[i]\n","            bin_idx = torch.bucketize(x[:, i], edges)\n","            bin_idx = torch.clamp(bin_idx, max=self.num_bins - 1)\n","            emb = self.embeds[i](bin_idx)\n","            all_embeds.append(emb)\n","        return torch.stack(all_embeds, dim=1)\n","\n","\n","\n","# ------------------------------\n","# Binned FT Transformer\n","# ------------------------------\n","\n","class HybridFTTransformer(nn.Module):\n","    def __init__(\n","        self,\n","        *,\n","        categories,\n","        binned_cols,\n","        linear_cols,\n","        dim,\n","        depth,\n","        heads,\n","        dim_head=16,\n","        dim_out=1,\n","        num_special_tokens=2,\n","        attn_dropout=0.0,\n","        ff_dropout=0.0,\n","        num_bins=32,\n","        binning=\"quantile\"\n","    ):\n","        super().__init__()\n","        self.num_categories = len(categories)\n","        self.num_unique_categories = sum(categories)\n","\n","        # record which features are binned vs linear\n","        self.binned_cols = binned_cols\n","        self.linear_cols = linear_cols\n","        self.num_binned = len(binned_cols)\n","        self.num_linear = len(linear_cols)\n","\n","        # --------------------\n","        # categorical embeddings\n","        # --------------------\n","        if self.num_unique_categories > 0:\n","            total_tokens = self.num_unique_categories + num_special_tokens\n","            categories_offset = F.pad(\n","                torch.tensor(list(categories)), (1, 0), value=num_special_tokens\n","            )\n","            categories_offset = categories_offset.cumsum(dim=-1)[:-1]\n","            self.register_buffer(\"categories_offset\", categories_offset)\n","            self.categorical_embeds = nn.Embedding(total_tokens, dim)\n","\n","        # --------------------\n","        # binned numeric embeddings\n","        # --------------------\n","        if self.num_binned > 0:\n","            self.binned_embedder = BinnedEmbedder(dim, self.num_binned, num_bins, binning)\n","\n","        # --------------------\n","        # linear numeric embeddings\n","        # --------------------\n","        if self.num_linear > 0:\n","            self.linear_proj = nn.Linear(self.num_linear, self.num_linear * dim)\n","            self.linear_norm = nn.LayerNorm(dim)\n","\n","        # --------------------\n","        # CLS token + Transformer\n","        # --------------------\n","        self.cls_token = nn.Parameter(torch.randn(1, 1, dim))\n","        self.transformer = Transformer(\n","            dim=dim,\n","            depth=depth,\n","            heads=heads,\n","            dim_head=dim_head,\n","            attn_dropout=attn_dropout,\n","            ff_dropout=ff_dropout,\n","        )\n","\n","        # --------------------\n","        # output head\n","        # --------------------\n","        self.to_logits = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.ReLU(),\n","            nn.Linear(dim, dim_out)\n","        )\n","\n","    # --------------------------\n","    # Bin fitting for binned subset\n","    # --------------------------\n","    def fit_bins(self, x_numer: pd.DataFrame):\n","        assert self.num_binned > 0, \"No binned features to fit.\"\n","        self.binned_embedder.fit(x_numer[self.binned_cols])\n","        print(f\"✅ Fitted bins for {self.num_binned} binned features.\")\n","\n","    # --------------------------\n","    # Forward\n","    # --------------------------\n","    def forward(self, x_categ, x_binned=None, x_linear=None, return_attn=False):\n","        xs = []\n","\n","        # categorical\n","        if self.num_unique_categories > 0:\n","            x_categ = x_categ + self.categories_offset\n","            xs.append(self.categorical_embeds(x_categ))\n","\n","        # binned numerical\n","        if self.num_binned > 0 and x_binned is not None:\n","            xs.append(self.binned_embedder(x_binned))\n","\n","        # linear numerical\n","        if self.num_linear > 0 and x_linear is not None:\n","            lin_emb = self.linear_proj(x_linear)  # [B, num_linear * dim]\n","            lin_emb = rearrange(lin_emb, \"b (n d) -> b n d\", n=self.num_linear)\n","            lin_emb = self.linear_norm(lin_emb)\n","            xs.append(lin_emb)\n","\n","        # concatenate all tokens\n","        x = torch.cat(xs, dim=1)\n","\n","        # add CLS token\n","        b = x.shape[0]\n","        cls_tokens = repeat(self.cls_token, \"1 1 d -> b 1 d\", b=b)\n","        x = torch.cat((cls_tokens, x), dim=1)\n","\n","        # transformer forward\n","        x, attns = self.transformer(x, return_attn=True)\n","        logits = self.to_logits(x[:, 0])\n","\n","        return (logits, attns) if return_attn else logits"]},{"cell_type":"markdown","metadata":{"id":"GQbua9hnyb3t"},"source":["======================================================================="]},{"cell_type":"code","source":["device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")"],"metadata":{"id":"xw2OxaMb9nHI","executionInfo":{"status":"ok","timestamp":1760969365975,"user_tz":-480,"elapsed":7,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":55,"outputs":[]},{"cell_type":"code","execution_count":56,"metadata":{"executionInfo":{"elapsed":207,"status":"ok","timestamp":1760969367621,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"GP2nhw8Hx73H"},"outputs":[],"source":["model = HybridFTTransformer(\n","    categories=cat_dims,  # cardinality per categorical column\n","    binned_cols=binned_cols,\n","    linear_cols=linear_cols,\n","    dim=64,\n","    depth=4,\n","    heads=8,\n","    dim_out=1,\n","    num_bins=16,\n",").to(device)"]},{"cell_type":"code","source":["from sklearn.utils.class_weight import compute_class_weight\n","from sklearn.metrics import precision_recall_curve, average_precision_score"],"metadata":{"id":"EloRm9Y5u9n0","executionInfo":{"status":"ok","timestamp":1760969369853,"user_tz":-480,"elapsed":16,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":57,"outputs":[]},{"cell_type":"code","source":["def get_best_threshold(y_true, y_probs, metric=\"f1\"):\n","    precision, recall, thresholds = precision_recall_curve(y_true, y_probs)\n","\n","    # Compute F1 for each threshold\n","    f1_scores = 2 * precision * recall / (precision + recall + 1e-8)\n","    auc_pr = average_precision_score(y_true, y_probs)\n","\n","    if metric == \"f1\":\n","        best_idx = np.argmax(f1_scores)\n","        best_score = f1_scores[best_idx]\n","    elif metric == \"precision\":\n","        best_idx = np.argmax(precision)\n","        best_score = precision[best_idx]\n","    elif metric == \"recall\":\n","        best_idx = np.argmax(recall)\n","        best_score = recall[best_idx]\n","    else:\n","        raise ValueError(\"metric must be one of: 'f1', 'precision', or 'recall'\")\n","\n","    best_threshold = thresholds[best_idx] if best_idx < len(thresholds) else 0.5\n","\n","    metrics = {\n","        \"best_metric\": metric,\n","        \"best_score\": best_score,\n","        \"best_threshold\": best_threshold,\n","        \"auc_pr\": auc_pr,\n","        \"precision_curve\": precision,\n","        \"recall_curve\": recall,\n","        \"f1_curve\": f1_scores,\n","        \"thresholds\": thresholds\n","    }\n","\n","    return best_threshold, metrics"],"metadata":{"id":"rakESQqwu-mZ","executionInfo":{"status":"ok","timestamp":1760969373129,"user_tz":-480,"elapsed":2,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":58,"outputs":[]},{"cell_type":"code","source":["# fit bins only on the binned subset\n","if len(binned_cols) > 0:\n","    binned_idxs = [train.columns.get_loc(c) for c in binned_cols]\n","\n","    # subset from numpy\n","    X_train_bin = X_train[:, binned_idxs]\n","\n","    # wrap back into DataFrame (optional)\n","    X_train_bin_df = pd.DataFrame(X_train_bin, columns=binned_cols)\n","\n","    model.fit_bins(X_train_bin_df)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"-jsMERF-bf5y","executionInfo":{"status":"ok","timestamp":1760969375483,"user_tz":-480,"elapsed":27,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"932348cb-8bae-4dc9-b765-4f62533a7229"},"execution_count":59,"outputs":[{"output_type":"stream","name":"stdout","text":["✅ Fitted bins for 15 binned features.\n"]}]},{"cell_type":"code","execution_count":60,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OquETEtzzZ-V","executionInfo":{"status":"ok","timestamp":1760969779047,"user_tz":-480,"elapsed":395049,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"251ed86e-c1bc-45e6-f973-d5ef1a408183"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","===== Epoch 1/10 =====\n"]},{"output_type":"stream","name":"stderr","text":["/tmp/ipython-input-1019931038.py:145: UserWarning: torch.searchsorted(): input value tensor is non-contiguous, this will lower the performance due to extra data copy when converting non-contiguous tensor to contiguous, please use contiguous input value tensor if possible. This message will only appear once per program. (Triggered internally at /pytorch/aten/src/ATen/native/BucketizationUtils.h:32.)\n","  bin_idx = torch.bucketize(x[:, i], edges)\n"]},{"output_type":"stream","name":"stdout","text":["Train BCE: 0.4166 | Val Loss: 0.4609 | Val Acc: 0.9991 | Val AUC-PR: 0.6423 | Best F1: 0.7302 | Thresh: 0.9903\n","✅ New best model saved (F1=0.7302)\n","\n","===== Epoch 2/10 =====\n","Train BCE: 0.2935 | Val Loss: 0.4588 | Val Acc: 0.9990 | Val AUC-PR: 0.5613 | Best F1: 0.7077 | Thresh: 0.9931\n","\n","===== Epoch 3/10 =====\n","Train BCE: 0.2260 | Val Loss: 0.4910 | Val Acc: 0.9987 | Val AUC-PR: 0.4338 | Best F1: 0.6094 | Thresh: 0.9833\n","\n","===== Epoch 4/10 =====\n","Train BCE: 0.2299 | Val Loss: 0.5513 | Val Acc: 0.9988 | Val AUC-PR: 0.4080 | Best F1: 0.6299 | Thresh: 0.9981\n","\n","===== Epoch 5/10 =====\n","Train BCE: 0.1501 | Val Loss: 0.4518 | Val Acc: 0.9989 | Val AUC-PR: 0.4899 | Best F1: 0.6875 | Thresh: 0.9945\n","\n","===== Epoch 6/10 =====\n","Train BCE: 0.1437 | Val Loss: 0.8214 | Val Acc: 0.9986 | Val AUC-PR: 0.4363 | Best F1: 0.6176 | Thresh: 0.9860\n","\n","===== Epoch 7/10 =====\n","Train BCE: 0.1006 | Val Loss: 0.7731 | Val Acc: 0.9986 | Val AUC-PR: 0.4639 | Best F1: 0.6176 | Thresh: 0.9871\n","\n","===== Epoch 8/10 =====\n","Train BCE: 0.1331 | Val Loss: 1.0269 | Val Acc: 0.9990 | Val AUC-PR: 0.5641 | Best F1: 0.6667 | Thresh: 0.9954\n","\n","===== Epoch 9/10 =====\n","Train BCE: 0.2440 | Val Loss: 1.4332 | Val Acc: 0.9989 | Val AUC-PR: 0.5244 | Best F1: 0.6429 | Thresh: 0.9979\n","\n","===== Epoch 10/10 =====\n","Train BCE: 0.1246 | Val Loss: 1.0080 | Val Acc: 0.9988 | Val AUC-PR: 0.4855 | Best F1: 0.6167 | Thresh: 0.9936\n","\n","Training completed. Best F1 = 0.7301587251700682\n"]}],"source":["from torch.optim import Adam\n","from sklearn.utils.class_weight import compute_class_weight\n","from sklearn.metrics import accuracy_score\n","import numpy as np\n","import torch\n","import torch.nn as nn\n","\n","# === Optimizer and Class Weights ===\n","optimizer = Adam(model.parameters(), lr=1e-3)\n","\n","classes = np.unique(y_train)\n","class_weights = compute_class_weight(class_weight='balanced', classes=classes, y=y_train)\n","class_weights = torch.tensor(class_weights, dtype=torch.float).to(device)\n","\n","criterion = nn.BCEWithLogitsLoss(pos_weight=class_weights[1])\n","\n","# === Training Configuration ===\n","num_epochs = 10\n","best_threshold = 0.5\n","best_f1 = 0.0\n","\n","for epoch in range(num_epochs):\n","    print(f\"\\n===== Epoch {epoch + 1}/{num_epochs} =====\")\n","    model.train()\n","    train_loss = 0.0\n","\n","    # ---------- TRAIN LOOP ----------\n","    for x_categ, x_binned, x_linear, y in train_loader:\n","        x_categ, x_binned, x_linear, y = (\n","            x_categ.to(device),\n","            x_binned.to(device),\n","            x_linear.to(device),\n","            y.to(device).float().unsqueeze(1)\n","        )\n","\n","        optimizer.zero_grad()\n","\n","        # Forward pass (hybrid model)\n","        logits = model(x_categ, x_binned, x_linear)\n","\n","        # Compute loss\n","        bce_loss = criterion(logits, y)\n","\n","        bce_loss.backward()\n","        optimizer.step()\n","\n","        train_loss += bce_loss.item()\n","\n","    avg_train_loss = train_loss / len(train_loader)\n","\n","    # ---------- VALIDATION ----------\n","    model.eval()\n","    val_loss = 0.0\n","    all_val_probs, all_val_labels = [], []\n","\n","    with torch.no_grad():\n","        for x_categ, x_binned, x_linear, y in valid_loader:\n","            x_categ, x_binned, x_linear, y = (\n","                x_categ.to(device),\n","                x_binned.to(device),\n","                x_linear.to(device),\n","                y.to(device).float().unsqueeze(1)\n","            )\n","\n","            logits = model(x_categ, x_binned, x_linear)\n","            bce_loss = criterion(logits, y)\n","            val_loss += bce_loss.item()\n","\n","            probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","            all_val_probs.extend(probs)\n","            all_val_labels.extend(y.cpu().numpy().astype(int).squeeze(1).tolist())\n","\n","    avg_val_loss = val_loss / len(valid_loader)\n","\n","    # ---------- Dynamic Threshold Optimization ----------\n","    best_threshold, metrics = get_best_threshold(all_val_labels, all_val_probs, metric=\"f1\")\n","    preds_bin = (np.array(all_val_probs) >= best_threshold).astype(int)\n","    val_acc = accuracy_score(all_val_labels, preds_bin)\n","\n","    # ---------- Logging ----------\n","    print(f\"Train BCE: {avg_train_loss:.4f} | \"\n","          f\"Val Loss: {avg_val_loss:.4f} | Val Acc: {val_acc:.4f} | \"\n","          f\"Val AUC-PR: {metrics['auc_pr']:.4f} | \"\n","          f\"Best F1: {metrics['best_score']:.4f} | Thresh: {best_threshold:.4f}\")\n","\n","    # ---------- Save Best Model ----------\n","    if metrics[\"best_score\"] > best_f1:\n","        best_f1 = metrics[\"best_score\"]\n","        torch.save(model.state_dict(), \"best_hybrid_ftt.pt\")\n","        print(f\"✅ New best model saved (F1={best_f1:.4f})\")\n","\n","print(\"\\nTraining completed. Best F1 =\", best_f1)"]},{"cell_type":"code","execution_count":61,"metadata":{"id":"0_u9H5FB55j0","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1760969799607,"user_tz":-480,"elapsed":4682,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"d7eb79a2-81ba-4ce9-9759-de66663685ef"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","🔍 Final Test Metrics:\n","Accuracy: 0.9988\n","F1 Score:  0.6383\n","AUC-PR:    0.5458\n","Best Threshold (from val): 0.9936\n"]}],"source":["# === 5️⃣ Final Test Evaluation ===\n","model.eval()\n","all_test_probs = []\n","all_test_preds = []\n","\n","with torch.no_grad():\n","    for x_categ, x_binned, x_linear, _ in test_loader:\n","        x_categ = x_categ.to(device)\n","        x_binned = x_binned.to(device)\n","        x_linear = x_linear.to(device)\n","\n","        # Forward pass (returns logits)\n","        logits = model(x_categ, x_binned, x_linear)\n","\n","        # Convert logits → probabilities (for binary classification)\n","        probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","        all_test_probs.extend(probs)\n","\n","        # Apply best threshold from validation\n","        preds_bin = (probs >= best_threshold).astype(int)\n","        all_test_preds.extend(preds_bin)\n","\n","# Convert to NumPy arrays\n","y_pred = np.array(all_test_preds)\n","y_prob = np.array(all_test_probs)\n","\n","# Compute metrics\n","test_acc = accuracy_score(y_test, y_pred)\n","test_f1 = f1_score(y_test, y_pred)\n","test_aucpr = average_precision_score(y_test, y_prob)\n","\n","print(f\"\\n🔍 Final Test Metrics:\")\n","print(f\"Accuracy: {test_acc:.4f}\")\n","print(f\"F1 Score:  {test_f1:.4f}\")\n","print(f\"AUC-PR:    {test_aucpr:.4f}\")\n","print(f\"Best Threshold (from val): {best_threshold:.4f}\")"]},{"cell_type":"code","execution_count":62,"metadata":{"id":"zGZ9KqXK0AiS","colab":{"base_uri":"https://localhost:8080/","height":472},"executionInfo":{"status":"ok","timestamp":1760969804933,"user_tz":-480,"elapsed":440,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"a537b106-12bf-487b-a25c-2a707395bde0"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# Confusion Matrix\n","cm = confusion_matrix(y_test, y_pred)\n","disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n","disp.plot(cmap=plt.cm.Blues)\n","plt.title(\"Confusion Matrix\")\n","plt.show()"]},{"cell_type":"code","source":["# Accuracy, Precision, Recall, F1-Score\n","accuracy = accuracy_score(y_test, y_pred)\n","precision = precision_score(y_test, y_pred)\n","recall = recall_score(y_test, y_pred)\n","f1 = f1_score(y_test, y_pred)\n","auc = roc_auc_score(y_test, y_pred)\n","\n","\n","# Print individual scores\n","print(f\"Accuracy: {accuracy:.4f}\")\n","print(f\"Precision: {precision:.4f}\")\n","print(f\"Recall: {recall:.4f}\")\n","print(f\"F1-Score: {f1:.4f}\")\n","print(f\"ROC-AUC: {auc:.4f}\")\n","\n","# Classification report for a detailed overview\n","print(classification_report(y_test, y_pred))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"VhO2p17A9x-K","executionInfo":{"status":"ok","timestamp":1760969808625,"user_tz":-480,"elapsed":49,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"f59a512a-53bd-4ebc-bf32-ffa6045157c3"},"execution_count":63,"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 0.9988\n","Precision: 0.6667\n","Recall: 0.6122\n","F1-Score: 0.6383\n","ROC-AUC: 0.8059\n","              precision    recall  f1-score   support\n","\n","           0       1.00      1.00      1.00     28432\n","           1       0.67      0.61      0.64        49\n","\n","    accuracy                           1.00     28481\n","   macro avg       0.83      0.81      0.82     28481\n","weighted avg       1.00      1.00      1.00     28481\n","\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"iogJ7zeoAorG"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"gpuType":"A100","authorship_tag":"ABX9TyP+dBsctG75Eilt/Svs+gre"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"},"accelerator":"GPU"},"nbformat":4,"nbformat_minor":0}