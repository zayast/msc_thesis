{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"executionInfo":{"elapsed":5232,"status":"ok","timestamp":1760909804251,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"QYO-HYkgZ4T3"},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import pandas as pd\n","import numpy as np\n","from sklearn.preprocessing import LabelEncoder\n","from sklearn.metrics import accuracy_score\n","from torch.utils.data import DataLoader, TensorDataset\n","from torch.optim import Adam\n","from sklearn.model_selection import train_test_split\n","import matplotlib.pyplot as plt"]},{"cell_type":"code","execution_count":2,"metadata":{"id":"VdpcwaM9z4TN","executionInfo":{"status":"ok","timestamp":1760909808540,"user_tz":-480,"elapsed":7,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"outputs":[],"source":["from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay\n","from sklearn.metrics import precision_score, recall_score, f1_score, classification_report\n","from sklearn.metrics import roc_auc_score, precision_recall_curve, f1_score"]},{"cell_type":"code","execution_count":3,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":25006,"status":"ok","timestamp":1760909835087,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"7lEomYw8aQbh","outputId":"20328954-d72c-4860-d38c-0eab15db6797"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"markdown","metadata":{"id":"5Q9MHkvXys9q"},"source":["=====================Data prepration============================="]},{"cell_type":"code","execution_count":4,"metadata":{"executionInfo":{"elapsed":34,"status":"ok","timestamp":1760909840246,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"JEb6Fm_HcbCy"},"outputs":[],"source":["# -----------------\n","# Helper: stratified sampling\n","# -----------------\n","def stratified_sample(df, target_col, frac=None, n=None, random_state=42):\n","    \"\"\"Return stratified sample keeping target ratio\"\"\"\n","    if frac is not None:\n","        df_sampled = df.groupby(target_col, group_keys=False)\\\n","                       .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n","    elif n is not None:\n","        class_counts = df[target_col].value_counts()\n","        total = class_counts.sum()\n","        df_sampled = []\n","        for c, count in class_counts.items():\n","            take = int(n * (count / total))\n","            df_sampled.append(df[df[target_col] == c].sample(n=take, random_state=random_state))\n","        df_sampled = pd.concat(df_sampled)\n","    else:\n","        df_sampled = df\n","    return df_sampled.sample(frac=1.0, random_state=random_state).reset_index(drop=True)"]},{"cell_type":"code","source":["dataset = \"B\"\n","\n","if dataset == \"A\":\n","  dataset_name = \"/content/drive/MyDrive/wustl_iiot_2021.csv\"\n","  target = 'Target'\n","  drop_cols = [\"StartTime\", \"LastTime\", \"Traffic\", \"SrcAddr\", \"DstAddr\"]\n","  frac=0.1\n","elif dataset == \"B\":\n","  dataset_name = \"/content/drive/MyDrive/creditcard.csv\"\n","  target = 'Class'\n","  drop_cols = [\"Time\"]\n","  frac=0.5"],"metadata":{"id":"zNLyODO3h4nL","executionInfo":{"status":"ok","timestamp":1760909843714,"user_tz":-480,"elapsed":34,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":5,"outputs":[]},{"cell_type":"code","execution_count":6,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":7471,"status":"ok","timestamp":1760909854845,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"tqQUooD0aAPH","outputId":"97524f77-73da-435e-f8f5-283ae3694ed4"},"outputs":[{"output_type":"stream","name":"stdout","text":["Original dataset shape: (284807, 30), anomaly ratio=0.1727%\n","Sampled dataset shape: (142404, 30), anomaly ratio=0.1727%\n"]},{"output_type":"stream","name":"stderr","text":["/tmp/ipython-input-2184620091.py:8: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n","  .apply(lambda x: x.sample(frac=frac, random_state=random_state))\n"]},{"output_type":"stream","name":"stdout","text":["Train shape: (75948, 30), anomaly ratio=0.1725%\n","Valid shape: (37975, 30), anomaly ratio=0.1738%\n","Test shape:  (28481, 30),  anomaly ratio=0.1720%\n","['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']\n","Categorical columns: []\n","Numerical columns: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10', 'V11', 'V12', 'V13', 'V14', 'V15', 'V16', 'V17', 'V18', 'V19', 'V20', 'V21', 'V22', 'V23', 'V24', 'V25', 'V26', 'V27', 'V28', 'Amount']\n","[]\n","[]\n"]}],"source":["df = pd.read_csv(dataset_name)\n","\n","df = df.drop(columns=[c for c in drop_cols if c in df.columns])\n","\n","print(f\"Original dataset shape: {df.shape}, anomaly ratio={df[target].mean():.4%}\")\n","\n","# Stratified sampling\n","df_sampled = stratified_sample(df, target, frac=frac, random_state=0)\n","print(f\"Sampled dataset shape: {df_sampled.shape}, anomaly ratio={df_sampled[target].mean():.4%}\")\n","\n","df_sampled = df_sampled.reset_index(drop=True)\n","\n","features = df_sampled.columns\n","\n","train_df, test_df = train_test_split(\n","    df_sampled, test_size=0.2, stratify=df_sampled[target], random_state=0\n",")\n","\n","train_df, valid_df = train_test_split(\n","    train_df, test_size= 0.2 / 0.6, stratify=train_df[target], random_state=0\n",")\n","\n","print(f\"Train shape: {train_df.shape}, anomaly ratio={train_df[target].mean():.4%}\")\n","print(f\"Valid shape: {valid_df.shape}, anomaly ratio={valid_df[target].mean():.4%}\")\n","print(f\"Test shape:  {test_df.shape},  anomaly ratio={test_df[target].mean():.4%}\")\n","\n","# Add the \"Set\" column\n","train_df[\"Set\"] = \"train\"\n","valid_df[\"Set\"] = \"valid\"\n","test_df[\"Set\"] = \"test\"\n","\n","# Combine them back together\n","train = pd.concat([train_df, valid_df, test_df]).reset_index(drop=True)\n","\n","train_indices = train[train.Set == \"train\"].index\n","valid_indices = train[train.Set == \"valid\"].index\n","test_indices = train[train.Set == \"test\"].index\n","\n","\n","categorical_columns = []\n","numerical_columns = []\n","categorical_dims = {}\n","\n","nunique = train.nunique()\n","types = train.dtypes\n","\n","for col in train.columns:\n","    if col == target or col == 'Set':\n","        continue\n","    if types[col] == 'object':\n","        l_enc = LabelEncoder()\n","        train[col] = train[col].fillna(\"VV_likely\")\n","        train[col] = l_enc.fit_transform(train[col].values)\n","        categorical_columns.append(col)\n","        categorical_dims[col] = len(l_enc.classes_)\n","    else:\n","        train.fillna(train.loc[train_indices, col].mean(), inplace=True)\n","        numerical_columns.append(col)\n","\n","unused_feat = [\"Set\"]\n","\n","features = [col for col in df_sampled.columns if col not in unused_feat + [target]]\n","\n","print(features)\n","print(\"Categorical columns:\", categorical_columns)\n","print(\"Numerical columns:\", numerical_columns)\n","\n","cat_idxs = [i for i, f in enumerate(features) if f in categorical_columns]\n","\n","print(cat_idxs)\n","cat_dims = [categorical_dims[f] for i, f in enumerate(features) if f in categorical_columns]\n","print(cat_dims)"]},{"cell_type":"code","execution_count":7,"metadata":{"executionInfo":{"elapsed":6,"status":"ok","timestamp":1760909854859,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"c-yxDUQHxt6F"},"outputs":[],"source":["target_enc = LabelEncoder()\n","train[target] = target_enc.fit_transform(train[target].values)"]},{"cell_type":"code","execution_count":8,"metadata":{"executionInfo":{"elapsed":7,"status":"ok","timestamp":1760909854877,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"oXFTqW5IblTA"},"outputs":[],"source":["X_train = train[features].values[train_indices]\n","y_train = train[target].values[train_indices]\n","\n","X_valid = train[features].values[valid_indices]\n","y_valid = train[target].values[valid_indices]\n","\n","X_test = train[features].values[test_indices]\n","y_test = train[target].values[test_indices]"]},{"cell_type":"code","source":["X_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"lrzMwFTWTTB8","executionInfo":{"status":"ok","timestamp":1760889100112,"user_tz":-480,"elapsed":5,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"e1fc40de-ebd1-4173-f471-5236be93ccd1"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([[-1.19197911e+00,  3.65650122e-01, -8.51445584e-01,\n","        -5.55876464e-02,  6.60455094e-01, -8.97987761e-01,\n","         9.17589518e-01, -1.09320231e+00, -3.04718385e-03,\n","        -3.14985028e-01,  1.37842811e+00,  5.80745705e-01,\n","         4.10150716e-02, -7.67188541e-01,  1.12237566e-01,\n","         2.29330820e-01,  2.57217208e-01,  1.05117226e+00,\n","         7.67926875e-02, -6.39738004e-01,  9.28457312e-01,\n","         1.00805213e+00,  5.59219071e-01, -4.87668841e-02,\n","        -1.88406839e-01, -1.33895716e-01,  3.85090717e-01,\n","         1.49271649e-01,  9.90000000e+01],\n","       [-1.10183428e+00,  1.42811407e+00,  1.75677727e+00,\n","         4.57016384e+00, -7.85317014e-01,  1.74108541e+00,\n","         4.60257243e-01,  4.84929055e-01, -7.22077270e-01,\n","         6.13497785e-01, -4.18485976e-01, -3.65065122e+00,\n","         1.53242701e+00,  1.78262993e+00,  7.01455562e-01,\n","         5.11940272e-01,  8.11029639e-01,  1.08387676e+00,\n","         7.74394808e-01,  1.48712822e-01,  1.01479933e-01,\n","         3.42363325e-01, -1.18869258e-01,  6.43704638e-01,\n","         1.74076932e-01,  4.92296165e-01, -9.15912795e-02,\n","        -2.42055297e-02,  2.26440000e+02]])"]},"metadata":{},"execution_count":32}]},{"cell_type":"code","source":["y_train[:2]"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"6ZaXye2RTUKI","executionInfo":{"status":"ok","timestamp":1760889102591,"user_tz":-480,"elapsed":15,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"c77b1ebd-1af1-49d4-ec3d-396b71d4eb3d"},"execution_count":null,"outputs":[{"output_type":"execute_result","data":{"text/plain":["array([0, 0])"]},"metadata":{},"execution_count":33}]},{"cell_type":"code","execution_count":19,"metadata":{"executionInfo":{"elapsed":7,"status":"ok","timestamp":1760910567148,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"XEizQZmXgxQm"},"outputs":[],"source":["# Split the data into categorical and continuous parts\n","X_train_categ = torch.tensor(X_train[:, cat_idxs], dtype=torch.long)\n","X_train_cont = torch.tensor(np.delete(X_train, cat_idxs, axis=1), dtype=torch.float32)\n","y_train_tensor = torch.tensor(y_train, dtype=torch.long)\n","\n","X_valid_categ = torch.tensor(X_valid[:, cat_idxs], dtype=torch.long)\n","X_valid_cont = torch.tensor(np.delete(X_valid, cat_idxs, axis=1), dtype=torch.float32)\n","y_valid_tensor = torch.tensor(y_valid, dtype=torch.long)\n","\n","X_test_categ = torch.tensor(X_test[:, cat_idxs], dtype=torch.long)\n","X_test_cont = torch.tensor(np.delete(X_test, cat_idxs, axis=1), dtype=torch.float32)\n","y_test_tensor = torch.tensor(y_test, dtype=torch.long)\n","\n","# Create DataLoaders\n","train_dataset = TensorDataset(X_train_categ, X_train_cont, y_train_tensor)\n","train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n","\n","valid_dataset = TensorDataset(X_valid_categ, X_valid_cont, y_valid_tensor)\n","valid_loader = DataLoader(valid_dataset, batch_size=32, shuffle=False)\n","\n","test_dataset = TensorDataset(X_test_categ, X_test_cont, y_test_tensor)\n","test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)"]},{"cell_type":"markdown","metadata":{"id":"6t0AMSr8y2Pe"},"source":["======================================================================"]},{"cell_type":"markdown","metadata":{"id":"Lbv9mESCyQNX"},"source":["==================================Model================================"]},{"cell_type":"code","execution_count":9,"metadata":{"executionInfo":{"elapsed":42,"status":"ok","timestamp":1760909860254,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"t9qv3vmlzpQx"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","\n","from einops import rearrange"]},{"cell_type":"code","execution_count":35,"metadata":{"executionInfo":{"elapsed":33,"status":"ok","timestamp":1760911497253,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"5UmJ2xwyy-AA"},"outputs":[],"source":["import torch\n","import torch.nn.functional as F\n","from torch import nn, einsum\n","from einops import rearrange, repeat\n","import numpy as np\n","import pandas as pd\n","\n","\n","# ------------------------------\n","# Core building blocks\n","# ------------------------------\n","\n","class GEGLU(nn.Module):\n","    def forward(self, x):\n","        x, gates = x.chunk(2, dim=-1)\n","        return x * F.gelu(gates)\n","\n","\n","def FeedForward(dim, mult=4, dropout=0.):\n","    return nn.Sequential(\n","        nn.LayerNorm(dim),\n","        nn.Linear(dim, dim * mult * 2),\n","        GEGLU(),\n","        nn.Dropout(dropout),\n","        nn.Linear(dim * mult, dim)\n","    )\n","\n","\n","class Attention(nn.Module):\n","    def __init__(self, dim, heads=8, dim_head=64, dropout=0.):\n","        super().__init__()\n","        inner_dim = dim_head * heads\n","        self.heads = heads\n","        self.scale = dim_head ** -0.5\n","        self.norm = nn.LayerNorm(dim)\n","        self.to_qkv = nn.Linear(dim, inner_dim * 3, bias=False)\n","        self.to_out = nn.Linear(inner_dim, dim, bias=False)\n","        self.dropout = nn.Dropout(dropout)\n","\n","    def forward(self, x):\n","        h = self.heads\n","        x = self.norm(x)\n","        q, k, v = self.to_qkv(x).chunk(3, dim=-1)\n","        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h=h), (q, k, v))\n","        q = q * self.scale\n","        sim = einsum('b h i d, b h j d -> b h i j', q, k)\n","        attn = sim.softmax(dim=-1)\n","        dropped_attn = self.dropout(attn)\n","        out = einsum('b h i j, b h j d -> b h i d', dropped_attn, v)\n","        out = rearrange(out, 'b h n d -> b n (h d)', h=h)\n","        out = self.to_out(out)\n","        return out, attn\n","\n","\n","class Transformer(nn.Module):\n","    def __init__(self, dim, depth, heads, dim_head, attn_dropout, ff_dropout):\n","        super().__init__()\n","        self.layers = nn.ModuleList([\n","            nn.ModuleList([\n","                Attention(dim, heads=heads, dim_head=dim_head, dropout=attn_dropout),\n","                FeedForward(dim, dropout=ff_dropout)\n","            ])\n","            for _ in range(depth)\n","        ])\n","\n","    def forward(self, x, return_attn=False):\n","        post_softmax_attns = []\n","        for attn, ff in self.layers:\n","            attn_out, post_softmax_attn = attn(x)\n","            post_softmax_attns.append(post_softmax_attn)\n","            x = attn_out + x\n","            x = ff(x) + x\n","        if not return_attn:\n","            return x\n","        return x, torch.stack(post_softmax_attns)\n","\n","\n","# ------------------------------\n","# Automatic Binning Embedder\n","# ------------------------------\n","\n","class BinnedEmbedder(nn.Module):\n","    def __init__(self, dim, num_continuous, num_bins=32, binning='quantile'):\n","        super().__init__()\n","        self.num_continuous = num_continuous\n","        self.num_bins = num_bins\n","        self.binning = binning\n","        self.embeds = nn.ModuleList([\n","            nn.Embedding(num_bins, dim) for _ in range(num_continuous)\n","        ])\n","        self.register_buffer('bin_edges', torch.zeros(num_continuous, num_bins - 1))\n","\n","    @torch.no_grad()\n","    def fit(self, data):\n","        if isinstance(data, pd.DataFrame):\n","            data = torch.tensor(data.values, dtype=torch.float32)\n","        elif not torch.is_tensor(data):\n","            raise TypeError(\"Input must be a torch.Tensor or pandas DataFrame\")\n","\n","        edges_list = []\n","        for i in range(self.num_continuous):\n","            col = data[:, i].cpu().numpy()\n","            col = col[~np.isnan(col)]\n","\n","            unique_vals = np.unique(col)\n","            if len(unique_vals) < 2:\n","                # constant column — make dummy edges\n","                edges = np.linspace(col.min() - 1e-6, col.max() + 1e-6, self.num_bins - 1)\n","            else:\n","                if self.binning == 'quantile':\n","                    quantiles = np.linspace(0, 1, self.num_bins)\n","                    edges = np.quantile(col, quantiles)\n","                    edges = np.unique(edges)[1:-1]  # drop dupes & endpoints\n","                elif self.binning == 'uniform':\n","                    edges = np.linspace(col.min(), col.max(), self.num_bins - 1)\n","                else:\n","                    raise ValueError(\"binning must be 'quantile' or 'uniform'\")\n","\n","            # --- Safety fix ---\n","            if len(edges) < self.num_bins - 1:\n","                last = edges[-1] if len(edges) > 0 else col.max()\n","                edges = np.pad(edges, (0, self.num_bins - 1 - len(edges)), constant_values=last)\n","\n","            edges_list.append(torch.tensor(edges, dtype=torch.float32))\n","\n","        self.set_bin_edges(edges_list)\n","\n","    # ✅ Add this method\n","    def set_bin_edges(self, edges_list):\n","        \"\"\"\n","        Store computed edges into model buffer safely.\n","        \"\"\"\n","        for i, edges in enumerate(edges_list):\n","            # Make sure number of edges matches expected dimension\n","            if edges.numel() != self.num_bins - 1:\n","                # pad if shorter\n","                pad_len = (self.num_bins - 1) - edges.numel()\n","                edges = F.pad(edges, (0, pad_len), value=edges[-1])\n","            self.bin_edges[i, :len(edges)] = edges\n","\n","    def forward(self, x):\n","        all_embeds = []\n","        for i in range(self.num_continuous):\n","            edges = self.bin_edges[i]\n","            bin_idx = torch.bucketize(x[:, i], edges)\n","            bin_idx = torch.clamp(bin_idx, max=self.num_bins - 1)\n","            emb = self.embeds[i](bin_idx)\n","            all_embeds.append(emb)\n","        return torch.stack(all_embeds, dim=1)\n","\n","\n","\n","# ------------------------------\n","# Binned FT Transformer\n","# ------------------------------\n","\n","class BinnedFTTransformer(nn.Module):\n","    def __init__(\n","        self,\n","        *,\n","        categories,\n","        num_continuous,\n","        dim,\n","        depth,\n","        heads,\n","        dim_head=16,\n","        dim_out=1,\n","        num_special_tokens=2,\n","        attn_dropout=0.,\n","        ff_dropout=0.,\n","        num_bins=32,\n","        binning='quantile'\n","    ):\n","        super().__init__()\n","        self.num_categories = len(categories)\n","        self.num_unique_categories = sum(categories)\n","        self.num_continuous = num_continuous\n","\n","        # Categorical embeddings\n","        if self.num_unique_categories > 0:\n","            total_tokens = self.num_unique_categories + num_special_tokens\n","            categories_offset = F.pad(torch.tensor(list(categories)), (1, 0), value=num_special_tokens)\n","            categories_offset = categories_offset.cumsum(dim=-1)[:-1]\n","            self.register_buffer('categories_offset', categories_offset)\n","            self.categorical_embeds = nn.Embedding(total_tokens, dim)\n","\n","        # Binned numerical embeddings\n","        if self.num_continuous > 0:\n","            self.binned_embedder = BinnedEmbedder(dim, num_continuous, num_bins, binning)\n","\n","        # CLS token\n","        self.cls_token = nn.Parameter(torch.randn(1, 1, dim))\n","\n","        # Transformer backbone\n","        self.transformer = Transformer(\n","            dim=dim, depth=depth, heads=heads, dim_head=dim_head,\n","            attn_dropout=attn_dropout, ff_dropout=ff_dropout\n","        )\n","\n","        # Output head\n","        self.to_logits = nn.Sequential(\n","            nn.LayerNorm(dim),\n","            nn.ReLU(),\n","            nn.Linear(dim, dim_out)\n","        )\n","\n","    # --------------------------\n","    # Auto bin fitting function\n","    # --------------------------\n","    def fit_bins(self, x_numer):\n","        \"\"\"\n","        Compute bin edges automatically from numerical training data\n","        x_numer: torch.Tensor or pandas.DataFrame [B, num_continuous]\n","        \"\"\"\n","        assert self.num_continuous > 0, \"No continuous features to bin.\"\n","        self.binned_embedder.fit(x_numer)\n","        print(\"✅ Bin edges fitted successfully.\")\n","\n","    def forward(self, x_categ, x_numer, return_attn=False):\n","        xs = []\n","\n","        # categorical features\n","        if self.num_unique_categories > 0:\n","            x_categ = x_categ + self.categories_offset\n","            xs.append(self.categorical_embeds(x_categ))\n","\n","        # continuous (binned)\n","        if self.num_continuous > 0:\n","            xs.append(self.binned_embedder(x_numer))\n","\n","        x = torch.cat(xs, dim=1)\n","        b = x.shape[0]\n","        cls_tokens = repeat(self.cls_token, '1 1 d -> b 1 d', b=b)\n","        x = torch.cat((cls_tokens, x), dim=1)\n","\n","        x, attns = self.transformer(x, return_attn=True)\n","        logits = self.to_logits(x[:, 0])\n","        return (logits, attns) if return_attn else logits"]},{"cell_type":"markdown","metadata":{"id":"GQbua9hnyb3t"},"source":["======================================================================="]},{"cell_type":"code","source":["device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")"],"metadata":{"id":"xw2OxaMb9nHI","executionInfo":{"status":"ok","timestamp":1760909882224,"user_tz":-480,"elapsed":7,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":11,"outputs":[]},{"cell_type":"code","execution_count":36,"metadata":{"executionInfo":{"elapsed":45,"status":"ok","timestamp":1760911501278,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"},"user_tz":-480},"id":"GP2nhw8Hx73H"},"outputs":[],"source":["model = BinnedFTTransformer(\n","    categories=cat_dims,    # categorical features\n","    num_continuous=len(features) - len(cat_dims), # number of continuous values\n","    dim=64,\n","    depth=3,\n","    heads=8,\n","    dim_out=1,\n","    num_bins=16,           # number of bins per feature\n","    binning='quantile'     # or 'uniform'\n",").to(device)"]},{"cell_type":"code","source":["from sklearn.utils.class_weight import compute_class_weight\n","from sklearn.metrics import precision_recall_curve, average_precision_score"],"metadata":{"id":"EloRm9Y5u9n0","executionInfo":{"status":"ok","timestamp":1760910236749,"user_tz":-480,"elapsed":61,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":15,"outputs":[]},{"cell_type":"code","source":["def get_best_threshold(y_true, y_probs, metric=\"f1\"):\n","    precision, recall, thresholds = precision_recall_curve(y_true, y_probs)\n","\n","    # Compute F1 for each threshold\n","    f1_scores = 2 * precision * recall / (precision + recall + 1e-8)\n","    auc_pr = average_precision_score(y_true, y_probs)\n","\n","    if metric == \"f1\":\n","        best_idx = np.argmax(f1_scores)\n","        best_score = f1_scores[best_idx]\n","    elif metric == \"precision\":\n","        best_idx = np.argmax(precision)\n","        best_score = precision[best_idx]\n","    elif metric == \"recall\":\n","        best_idx = np.argmax(recall)\n","        best_score = recall[best_idx]\n","    else:\n","        raise ValueError(\"metric must be one of: 'f1', 'precision', or 'recall'\")\n","\n","    best_threshold = thresholds[best_idx] if best_idx < len(thresholds) else 0.5\n","\n","    metrics = {\n","        \"best_metric\": metric,\n","        \"best_score\": best_score,\n","        \"best_threshold\": best_threshold,\n","        \"auc_pr\": auc_pr,\n","        \"precision_curve\": precision,\n","        \"recall_curve\": recall,\n","        \"f1_curve\": f1_scores,\n","        \"thresholds\": thresholds\n","    }\n","\n","    return best_threshold, metrics"],"metadata":{"id":"rakESQqwu-mZ","executionInfo":{"status":"ok","timestamp":1760910238340,"user_tz":-480,"elapsed":43,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}}},"execution_count":16,"outputs":[]},{"cell_type":"code","source":["X_train_df = pd.DataFrame(X_train, columns=numerical_columns)\n","model.fit_bins(X_train_df)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"-jsMERF-bf5y","executionInfo":{"status":"ok","timestamp":1760911513606,"user_tz":-480,"elapsed":16,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"db4afe78-ede7-4f2b-8db7-2d2e6fb8a51d"},"execution_count":37,"outputs":[{"output_type":"stream","name":"stdout","text":["✅ Bin edges fitted successfully.\n"]}]},{"cell_type":"code","execution_count":39,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"OquETEtzzZ-V","executionInfo":{"status":"ok","timestamp":1760912001330,"user_tz":-480,"elapsed":376545,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"a55b3f66-5d4e-4bbd-ffea-ab7f2caf9c89"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","===== Epoch 1/10 =====\n","Train BCE: 0.4331 | Val Loss: 0.3446 | Val Acc: 0.9988 | Val AUC-PR: 0.3722 | Best F1: 0.6667 | Thresh: 0.9084\n","✅ New best model saved (F1=0.6667)\n","\n","===== Epoch 2/10 =====\n","Train BCE: 0.3411 | Val Loss: 0.3922 | Val Acc: 0.9990 | Val AUC-PR: 0.6146 | Best F1: 0.7132 | Thresh: 0.9891\n","✅ New best model saved (F1=0.7132)\n","\n","===== Epoch 3/10 =====\n","Train BCE: 0.2939 | Val Loss: 0.3764 | Val Acc: 0.9991 | Val AUC-PR: 0.6183 | Best F1: 0.7344 | Thresh: 0.9921\n","✅ New best model saved (F1=0.7344)\n","\n","===== Epoch 4/10 =====\n","Train BCE: 0.2733 | Val Loss: 0.4771 | Val Acc: 0.9990 | Val AUC-PR: 0.4959 | Best F1: 0.7164 | Thresh: 0.9979\n","\n","===== Epoch 5/10 =====\n","Train BCE: 0.2620 | Val Loss: 0.5705 | Val Acc: 0.9990 | Val AUC-PR: 0.5689 | Best F1: 0.7068 | Thresh: 0.9944\n","\n","===== Epoch 6/10 =====\n","Train BCE: 0.2396 | Val Loss: 0.3845 | Val Acc: 0.9991 | Val AUC-PR: 0.6037 | Best F1: 0.7187 | Thresh: 0.9964\n","\n","===== Epoch 7/10 =====\n","Train BCE: 0.2455 | Val Loss: 0.6530 | Val Acc: 0.9988 | Val AUC-PR: 0.5150 | Best F1: 0.6271 | Thresh: 0.9529\n","\n","===== Epoch 8/10 =====\n","Train BCE: 0.2391 | Val Loss: 0.3577 | Val Acc: 0.9989 | Val AUC-PR: 0.5804 | Best F1: 0.6719 | Thresh: 0.9615\n","\n","===== Epoch 9/10 =====\n","Train BCE: 0.1618 | Val Loss: 0.5831 | Val Acc: 0.9990 | Val AUC-PR: 0.6010 | Best F1: 0.7164 | Thresh: 0.9869\n","\n","===== Epoch 10/10 =====\n","Train BCE: 0.1865 | Val Loss: 0.4236 | Val Acc: 0.9991 | Val AUC-PR: 0.6156 | Best F1: 0.7187 | Thresh: 0.9828\n","\n","Training completed. Best F1 = 0.734374995004883\n"]}],"source":["from torch.optim import Adam\n","from sklearn.utils.class_weight import compute_class_weight\n","from sklearn.metrics import accuracy_score\n","import numpy as np\n","import torch.nn as nn\n","import torch\n","\n","# === Optimizer and Class Weights ===\n","optimizer = Adam(model.parameters(), lr=1e-3)\n","\n","classes = np.unique(y_train)\n","class_weights = compute_class_weight(class_weight='balanced', classes=classes, y=y_train)\n","class_weights = torch.tensor(class_weights, dtype=torch.float).to(device)\n","\n","criterion = nn.BCEWithLogitsLoss(pos_weight=class_weights[1])\n","\n","# === Training Configuration ===\n","num_epochs = 10\n","best_threshold = 0.5\n","best_f1 = 0.0\n","\n","for epoch in range(num_epochs):\n","    print(f\"\\n===== Epoch {epoch+1}/{num_epochs} =====\")\n","    model.train()\n","    train_loss = 0.0\n","\n","    # ---------- TRAIN LOOP ----------\n","    for x_categ, x_cont, y in train_loader:\n","        x_categ, x_cont, y = (\n","            x_categ.to(device),\n","            x_cont.to(device),\n","            y.to(device).float().unsqueeze(1)\n","        )\n","\n","        optimizer.zero_grad()\n","\n","        # Forward pass (logits only)\n","        logits = model(x_categ, x_cont)\n","        bce_loss = criterion(logits, y)\n","\n","        bce_loss.backward()\n","        optimizer.step()\n","\n","        train_loss += bce_loss.item()\n","\n","    avg_train_loss = train_loss / len(train_loader)\n","\n","    # ---------- VALIDATION ----------\n","    model.eval()\n","    val_loss = 0.0\n","    all_val_probs, all_val_labels = [], []\n","\n","    with torch.no_grad():\n","        for x_categ, x_cont, y in valid_loader:\n","            x_categ, x_cont, y = (\n","                x_categ.to(device),\n","                x_cont.to(device),\n","                y.to(device).float().unsqueeze(1)\n","            )\n","\n","            logits = model(x_categ, x_cont)\n","            bce_loss = criterion(logits, y)\n","            val_loss += bce_loss.item()\n","\n","            probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","            all_val_probs.extend(probs)\n","            all_val_labels.extend(y.cpu().numpy().astype(int).squeeze(1).tolist())\n","\n","    avg_val_loss = val_loss / len(valid_loader)\n","\n","    # ---------- Dynamic Threshold Optimization ----------\n","    best_threshold, metrics = get_best_threshold(all_val_labels, all_val_probs, metric=\"f1\")\n","    preds_bin = (np.array(all_val_probs) >= best_threshold).astype(int)\n","    val_acc = accuracy_score(all_val_labels, preds_bin)\n","\n","    # ---------- Logging ----------\n","    print(f\"Train BCE: {avg_train_loss:.4f} | \"\n","          f\"Val Loss: {avg_val_loss:.4f} | Val Acc: {val_acc:.4f} | \"\n","          f\"Val AUC-PR: {metrics['auc_pr']:.4f} | \"\n","          f\"Best F1: {metrics['best_score']:.4f} | Thresh: {best_threshold:.4f}\")\n","\n","    # Save best model\n","    if metrics[\"best_score\"] > best_f1:\n","        best_f1 = metrics[\"best_score\"]\n","        torch.save(model.state_dict(), \"best_binned_ftt.pt\")\n","        print(f\"✅ New best model saved (F1={best_f1:.4f})\")\n","\n","print(\"\\nTraining completed. Best F1 =\", best_f1)"]},{"cell_type":"code","execution_count":41,"metadata":{"id":"0_u9H5FB55j0","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1760912158396,"user_tz":-480,"elapsed":5211,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"407b3efd-f764-462f-9e0c-e37a59b09269"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","🔍 Final Test Metrics:\n","Accuracy: 0.9991\n","F1 Score:  0.7423\n","AUC-PR:    0.7318\n","Best Threshold (from val): 0.9828\n"]}],"source":["# === 5️⃣ Final Test Evaluation ===\n","model.eval()\n","all_test_probs = []\n","all_test_preds = []\n","\n","with torch.no_grad():\n","    for x_categ, x_cont, _ in test_loader:\n","        x_categ, x_cont = x_categ.to(device), x_cont.to(device)\n","\n","        # Forward pass (returns only logits)\n","        logits = model(x_categ, x_cont)\n","\n","        # Convert logits → probabilities\n","        probs = torch.sigmoid(logits).cpu().numpy().squeeze(1)\n","        all_test_probs.extend(probs)\n","\n","        # Apply best threshold from validation\n","        preds_bin = (probs >= best_threshold).astype(int)\n","        all_test_preds.extend(preds_bin)\n","\n","# Convert to NumPy arrays\n","y_pred = np.array(all_test_preds)\n","y_prob = np.array(all_test_probs)\n","\n","# Compute metrics\n","test_acc = accuracy_score(y_test, y_pred)\n","test_f1 = f1_score(y_test, y_pred)\n","test_aucpr = average_precision_score(y_test, y_prob)\n","\n","print(f\"\\n🔍 Final Test Metrics:\")\n","print(f\"Accuracy: {test_acc:.4f}\")\n","print(f\"F1 Score:  {test_f1:.4f}\")\n","print(f\"AUC-PR:    {test_aucpr:.4f}\")\n","print(f\"Best Threshold (from val): {best_threshold:.4f}\")\n"]},{"cell_type":"code","execution_count":42,"metadata":{"id":"zGZ9KqXK0AiS","colab":{"base_uri":"https://localhost:8080/","height":472},"executionInfo":{"status":"ok","timestamp":1760912166643,"user_tz":-480,"elapsed":486,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"d87ecc16-3775-400b-b07d-f85ed088d43f"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 2 Axes>"],"image/png":"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\n"},"metadata":{}}],"source":["# Confusion Matrix\n","cm = confusion_matrix(y_test, y_pred)\n","disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n","disp.plot(cmap=plt.cm.Blues)\n","plt.title(\"Confusion Matrix\")\n","plt.show()"]},{"cell_type":"code","source":["# Accuracy, Precision, Recall, F1-Score\n","accuracy = accuracy_score(y_test, y_pred)\n","precision = precision_score(y_test, y_pred)\n","recall = recall_score(y_test, y_pred)\n","f1 = f1_score(y_test, y_pred)\n","auc = roc_auc_score(y_test, y_pred)\n","\n","\n","# Print individual scores\n","print(f\"Accuracy: {accuracy:.4f}\")\n","print(f\"Precision: {precision:.4f}\")\n","print(f\"Recall: {recall:.4f}\")\n","print(f\"F1-Score: {f1:.4f}\")\n","print(f\"ROC-AUC: {auc:.4f}\")\n","\n","# Classification report for a detailed overview\n","print(classification_report(y_test, y_pred))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"VhO2p17A9x-K","executionInfo":{"status":"ok","timestamp":1760912179295,"user_tz":-480,"elapsed":16,"user":{"displayName":"Munkhzaya Bayanbat","userId":"02841352344795048115"}},"outputId":"81e1f279-e9c6-4b05-bd87-330cb8d162f4"},"execution_count":43,"outputs":[{"output_type":"stream","name":"stdout","text":["Accuracy: 0.9991\n","Precision: 0.7500\n","Recall: 0.7347\n","F1-Score: 0.7423\n","ROC-AUC: 0.8671\n","              precision    recall  f1-score   support\n","\n","           0       1.00      1.00      1.00     28432\n","           1       0.75      0.73      0.74        49\n","\n","    accuracy                           1.00     28481\n","   macro avg       0.87      0.87      0.87     28481\n","weighted avg       1.00      1.00      1.00     28481\n","\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"iogJ7zeoAorG"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"gpuType":"A100","authorship_tag":"ABX9TyPcsKvH7vFNBebu054RaVmi"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"},"accelerator":"GPU"},"nbformat":4,"nbformat_minor":0}